<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[git基本使用]]></title>
      <url>%2F2018%2F03%2F26%2Fgit%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[向远程仓库提交文件git push -u origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[不限宽居中]]></title>
      <url>%2F2018%2F03%2F26%2F%E4%B8%8D%E9%99%90%E5%AE%BD%E5%B1%85%E4%B8%AD%2F</url>
      <content type="text"><![CDATA[123&lt;div class="wrap"&gt; &lt;div class="inner"&gt;html ： 让 inner 居中&lt;/div&gt;&lt;/div&gt; 123456789.wrap &#123; float: left; /* 自适应内容宽度 */ position: relative; left: 50%; &#125;.inner &#123; position: relative; left: -50%; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取浏览器名称和版本]]></title>
      <url>%2F2018%2F03%2F26%2F%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8D%E7%A7%B0%E5%92%8C%E7%89%88%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021function getBroswer()&#123; var sys = &#123;&#125;; var ua = navigator.userAgent.toLowerCase(); var s; (s = ua.match(/edge\/([\d.]+)/)) ? sys.edge = s[1] : (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1] : (s = ua.match(/msie ([\d.]+)/)) ? sys.ie = s[1] : (s = ua.match(/firefox\/([\d.]+)/)) ? sys.firefox = s[1] : (s = ua.match(/chrome\/([\d.]+)/)) ? sys.chrome = s[1] : (s = ua.match(/opera.([\d.]+)/)) ? sys.opera = s[1] : (s = ua.match(/version\/([\d.]+).*safari/)) ? sys.safari = s[1] : 0; if (sys.edge) return &#123; broswer : "Edge", version : sys.edge &#125;; if (sys.ie) return &#123; broswer : "IE", version : sys.ie &#125;; if (sys.firefox) return &#123; broswer : "Firefox", version : sys.firefox &#125;; if (sys.chrome) return &#123; broswer : "Chrome", version : sys.chrome &#125;; if (sys.opera) return &#123; broswer : "Opera", version : sys.opera &#125;; if (sys.safari) return &#123; broswer : "Safari", version : sys.safari &#125;; return &#123; broswer : "", version : "0" &#125;;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue获取图片]]></title>
      <url>%2F2017%2F11%2F15%2FVue%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%2F</url>
      <content type="text"><![CDATA[12&lt;input type="file" ref="file"&gt;&lt;button @click="getFile()"&gt;获取&lt;/button&gt; 12345678910111213getImg()&#123; //获取文件 let file = this.$refs.file.files[0] //创建读取文件 let reader = new FileReader() let img //读文件 reader.onload = e =&gt; &#123; img = e.target.result console.log(img) &#125; reader.readAsDataURL(file)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue+Codrova混合App开发]]></title>
      <url>%2F2017%2F10%2F25%2FVue-Codrova%E6%B7%B7%E5%90%88App%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[Cordova插件在Vue中使用： 安装Cordova插件(手机状态栏-沉浸模式)参考 1cordova plugin add cordova-plugin-statusbar 安装Vue-Cordova插件 1npm install --save vue-cordova 123456789import Vue from 'vue'import VueCordova from 'vue-cordova'Vue.use(VueCordova)Vue.cordova.on('deviceready', () =&gt; &#123; // Cordova插件使用 if (cordova.platformId == 'android') &#123; StatusBar.backgroundColorByHexString("#333"); &#125;&#125;); 如果插件不好用 需要在index.html中加上：1&lt;script type=text/javascript src="cordova.js"&gt;&lt;/script&gt; backbutton事件,app退出消息弹出框插件：文档app1cordova plugin add cordova-plugin-x-toast 123456789101112131415161718Vue.cordova.on('deviceready', () =&gt; &#123; Vue.cordova.on('backbutton', eventBackButton) let backEventCount = 0 function eventBackButton() &#123; if (backEventCount === 0) &#123; backEventCount += 1 window.plugins.toast.showLongCenter('再点击一次退出') document.removeEventListener('backbutton', eventBackButton) setTimeout(() =&gt; &#123; backEventCount = 0 &#125;, 2000) &#125; else if (backEventCount === 1) &#123; navigator.app.exitApp() &#125; &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GoLang]]></title>
      <url>%2F2017%2F10%2F18%2FGoLang%2F</url>
      <content type="text"><![CDATA[golang图标超级萌 golang web服务器参看0参看1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( "fmt" "net/http" "log" "gopkg.in/mgo.v2" "gopkg.in/mgo.v2/bson" "encoding/json")type Person struct &#123; Name string Phone string&#125;func sayhelloName(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "Hello astaxie!") //这个写入到w的是输出到客户端的&#125;func sayLoveYou(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "love you!")&#125;func getdata(w http.ResponseWriter,r *http.Request) &#123; session, err := mgo.Dial("localhost:27017") if err != nil &#123; panic(err) &#125; session.SetMode(mgo.Monotonic, true) c := session.DB("test").C("people") resust := Person&#123;&#125; c.Find(bson.M&#123;"name": "Anson"&#125;).One(&amp;resust) //fmt.Fprintf(w, resust.Name) // return json user := Person&#123; resust.Name, resust.Phone, &#125; json.NewEncoder(w).Encode(user)&#125;func main() &#123; http.HandleFunc("/", sayhelloName) //设置访问的路由 http.HandleFunc("/love", sayLoveYou) http.HandleFunc("/get",getdata) err := http.ListenAndServe(":9090", nil) //设置监听的端口 if err != nil &#123; log.Fatal("ListenAndServe: ", err) &#125;&#125; 连接mongodb数据库 获取mgo，mgo是MongoDB的Go语言驱动mgo使用指南官方文档golang中使用MongoDB 1go get gopkg.in/mgo.v2 连接mongodb 1session, err := mgo.Dial(url) 使用数据库，没有会自行创建 1db := session.DB("test") 使用数据库中的集合 123c := db.C("people")// 或者c := session.DB("test").C("people") 建立数据模型 1234type Person struct &#123; Name string Phone string&#125; 插入数据 1c.Insert(&amp;Person&#123;"Anson", "1555555555"&#125;) 查询数据 1234result := Person&#123;&#125;c.Find(bson.M&#123;"name": "Anson"&#125;).One(&amp;result)//result代理查询结果fmt.Println("Phone:", result.Phone) 查询所有数据 1234//Person 为数据模型var result []Personc.Find(bson.M&#123;&#125;).All(&amp;result)fmt.Println("Phone:", result[0]) 更新数据 1c.Update(bson.M&#123;"name":"Anson"&#125;, &amp;Person&#123;"zhiyu","1666666666"&#125;) 更新所有数据 1暂无 删除数据 1c.Remove(bson.M&#123;"name":"Anson2"&#125;) 完整版：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( "gopkg.in/mgo.v2" "log" "gopkg.in/mgo.v2/bson" "fmt")func main() &#123; session, err := mgo.Dial("localhost:27017") if err != nil &#123; panic(err) &#125; session.SetMode(mgo.Monotonic, true) type Person struct &#123; Name string Phone string &#125; // Connect to the database c := session.DB("test").C("people") // insert data err = c.Insert(&amp;Person&#123;"Anson", "1555555555"&#125;) if err != nil &#123; log.Fatal(err) &#125; // find data //result := Person&#123;&#125; //err = c.Find(bson.M&#123;"name": "Anson"&#125;).One(&amp;result) // up data //err = c.Update(bson.M&#123;"name":"Anson"&#125;, &amp;Person&#123;"zhiyu","1666666666"&#125;) // delete data //err = c.Remove(bson.M&#123;"name": "Anson"&#125;) // find data all var result []Person err = c.Find(bson.M&#123;&#125;).All(&amp;result) if err != nil &#123; log.Fatal(err) &#125; fmt.Println("Phone:", result[0])&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM新增API]]></title>
      <url>%2F2017%2F10%2F17%2FDOM%E6%96%B0%E5%A2%9EAPI%2F</url>
      <content type="text"><![CDATA[before after prepend append 1. before向节点前插入文字12345&lt;span id="span"&gt;我是正常文字&lt;/s&gt;&lt;script&gt; document.getElementById('span').before('before')&lt;/script&gt; 向节点前插入html1234567&lt;span id="span"&gt;我是正常文字&lt;/s&gt;&lt;script&gt; const eleBefore = document.createElement('h4') eleBefore.innerHTML = '&lt;p&gt;before.&lt;/p&gt;' document.getElementById('span').before(eleBefore)&lt;/script&gt; 兼容性：before() API Chrome54+，Firefox49+使用polyfill JS ，兼容到IE91234567891011121314151617181920212223(function (arr) &#123; arr.forEach(function (item) &#123; if (item.hasOwnProperty('before')) &#123; return; &#125; Object.defineProperty(item, 'before', &#123; configurable: true, enumerable: true, writable: true, value: function before() &#123; var argArr = Array.prototype.slice.call(arguments), docFrag = document.createDocumentFragment(); argArr.forEach(function (argItem) &#123; var isNode = argItem instanceof Node; docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem))); &#125;); this.parentNode.insertBefore(docFrag, this); &#125; &#125;); &#125;);&#125;)([Element.prototype, CharacterData.prototype, DocumentType.prototype]); 2. after用法与before一致 兼容性：使用polyfill JS ，兼容到IE91234567891011121314151617181920212223(function (arr) &#123; arr.forEach(function (item) &#123; if (item.hasOwnProperty('after')) &#123; return; &#125; Object.defineProperty(item, 'after', &#123; configurable: true, enumerable: true, writable: true, value: function after() &#123; var argArr = Array.prototype.slice.call(arguments), docFrag = document.createDocumentFragment(); argArr.forEach(function (argItem) &#123; var isNode = argItem instanceof Node; docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem))); &#125;); this.parentNode.insertBefore(docFrag, this.nextSibling); &#125; &#125;); &#125;);&#125;)([Element.prototype, CharacterData.prototype, DocumentType.prototype]); 3. prepend表示在当前节点的最前面插入其它节点内容（作为子节点）。语法和前相似 兼容性：使用polyfill JS ，兼容到IE91234567891011121314151617181920212223(function (arr) &#123; arr.forEach(function (item) &#123; if (item.hasOwnProperty('prepend')) &#123; return; &#125; Object.defineProperty(item, 'prepend', &#123; configurable: true, enumerable: true, writable: true, value: function prepend() &#123; var argArr = Array.prototype.slice.call(arguments), docFrag = document.createDocumentFragment(); argArr.forEach(function (argItem) &#123; var isNode = argItem instanceof Node; docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem))); &#125;); this.insertBefore(docFrag, this.firstChild); &#125; &#125;); &#125;);&#125;)([Element.prototype, Document.prototype, DocumentFragment.prototype]); 4. append表示在当前节点的最后面插入其它节点内容（作为子节点）。语法与前相似 兼容性：使用polyfill JS ，兼容到IE91234567891011121314151617181920212223(function (arr) &#123; arr.forEach(function (item) &#123; if (item.hasOwnProperty('append')) &#123; return; &#125; Object.defineProperty(item, 'append', &#123; configurable: true, enumerable: true, writable: true, value: function append() &#123; var argArr = Array.prototype.slice.call(arguments), docFrag = document.createDocumentFragment(); argArr.forEach(function (argItem) &#123; var isNode = argItem instanceof Node; docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem))); &#125;); this.appendChild(docFrag); &#125; &#125;); &#125;);&#125;)([Element.prototype, Document.prototype, DocumentFragment.prototype]);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5语义化]]></title>
      <url>%2F2017%2F10%2F17%2Fhtml5%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
      <content type="text"><![CDATA[HTML5语义化 语义化作用： 搜索引擎友好。 更容易让屏幕阅读器读出网页内容。 去掉或样式丢失的时候能让页面呈现清晰的结构。 便于团队开发和维护。基本结构：常用标签&lt;header&gt;&lt;/header&gt;：页眉通常包括网站标志、主导航、全站链接以及搜索框。也适合对页面内部一组介绍性或导航性内容进行标记。&lt;nav&gt;&lt;/nav&gt;：标记导航，仅对文档中重要的链接群使用。html5规范不推荐对辅助性页脚链接使用nav，除非页脚再次显示顶级全局导航、或者包含招聘信息等重要链接。&lt;main&gt;&lt;/main&gt;：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。&lt;section&gt;&lt;/section&gt;：表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading）。&lt;article&gt;&lt;/article&gt;：是一个特殊的section标签，它比section具有更明确的语义，它代表一个独立的、完整的相关内容块，可独立于页面其它内容使用。例如一篇完整的论坛帖子，一篇博客文章，一个用户评论等等。一般来说，article会有标题部分（通常包含在header内），有时也会包含footer。article可以嵌套，内层的article对外层的article标签有隶属关系。例如，一篇博客的文章，可以用article显示，然后一些评论可以以article的形式嵌入其中。&lt;aside&gt;&lt;/aside&gt;：指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。如果放在main内，应该与所在内容密切相关。&lt;footer&gt;&lt;/footer&gt;：页脚，只有当父级是body时，才是整个页面的页脚&lt;figure&gt;&lt;/figure&gt;：创建图（默认有40px左右margin）。&lt;figcaption&gt;&lt;/figcaption&gt;：figure的标题，必须是figure内嵌的第一个或者最后一个元素。&lt;time&gt;&lt;/time&gt;：标签定义日期或时间，或者两者。1&lt;time datetime="2017-10-17"&gt;2017.10.17&lt;/time&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB的基本使用方法]]></title>
      <url>%2F2017%2F09%2F30%2Fmongoose%E6%93%8D%E4%BD%9CmongoDB%2F</url>
      <content type="text"><![CDATA[Mongodb一些基本使用方法总结 Ubuntu安装mongodb相关连接 1. 安装1sudo apt-get install mongodb 查看版本1mongo -version 开启和关闭12service mongodb startservice mongodb stop 默认设置MongoDB是随Ubuntu启动自动启动的。 查看是否启动成功1pgrep mongo -l 卸载MongoDB1sudo apt-get --purge remove mongodb mongodb-clients mongodb-server Mongodb数据迁移参考 备份1mongodump -h dbhost -d dbname -o dbdirectory -h: mongodb所在服务器地址，例如127.0.0.1，也可以指定端口:127.0.0.1:8080 -d: 需要备份的数据库名称，例如：test_data -o: 备份的数据存放的位置，例如：/home/bak -u: 用户名称，使用权限验证的mongodb服务，需要指明导出账号 -p： 用户密码，使用权限验证的mongodb服务，需要指明导出账号密码 恢复1mongorestore -d test --drop dbdirectory -d: 需要恢复备份的数据库名称，例如：test_data，可以跟原来备份的数据库名称不一样 dbdirectory: 备份数据所在位置，例如：/home/bak/test -drop: 加上这个参数的时候，会在恢复数据之前删除当前数据 MongoDB可视化工具使用Node工具操作 MongoDB 数据库 monk Monk模块基本用法1npm i monk 123456789101112131415161718192021222324252627282930//连接mydb数据库const db = require('monk')('localhost/mydb')db.then(() =&gt; console.log('Connected correctly to server'))//获取数据表const users = db.get('document')//添加数据users.insert(&#123; name: "zhiyu", password: '123'&#125;).then((res) =&gt; console.log('Yes')).catch((err)=&gt;console.log(err))//更新数据let old_date = &#123;name: "zhiyu",password: '123'&#125;, up_date= &#123;name: "zhiyu",password: '789'&#125; users.update(old_date,up_date) .then((res)=&gt;console.log('OK')) .catch((err)=&gt;console.log(err))//删除数据let del_date = &#123;name: "anson",password: '789'&#125; users.remove(del_date) .then((res)=&gt;console.log('OK')) .catch((err)=&gt;console.log(err))//查找数据let find_date = &#123;password: '789'&#125; users.find(find_date) .then((res)=&gt;console.log(res)) .catch((err)=&gt;console.log(err)) Mongoose1npm i mongoose mongoose官网mongoose教程-1mongoose教程-2mongoose教程-312345678server│ mongodb.js│ ├─controllers│ test.js│ ├─module│ test.js mongodb.js - 连接数据库12345678910const mongoose = require('mongoose')mongoose.Promise = global.Promiseconst config = require('./../config/index')mongoose.connect('127.0.0.1', &#123; useMongoClient: true, promiseLibrary: global.Promise&#125;)module.exports = mongoose 定义数据模型 - model/test.js1234567891011121314151617181920const mongoose = require('./../server/mongodb')const testSchema = new mongoose.Schema(&#123; hidden: Boolean, title: String, createTime: Date, content: String&#125;)testSchema.set('toJSON', &#123; getters: true, virtuals: true&#125;)testSchema.set('toObject', &#123; getters: true, virtuals: true&#125;)const test = mongoose.model('test', testSchema)module.exports = test 控制器获取数据 - controller/test.js引入test数据模型1const Test = require('./../module/test') 插入数据 先new 引入的模型 ， 并赋值给变量 再对变量进行save() , 并返回结果 1234567891011121314const create = async ctx =&gt; &#123; const test = new Test(&#123; hidden: ctx.request.body.hidden, title: ctx.request.body.title, createTime: new Date(), content: ctx.request.body.content &#125;) let result = await test.save().catch(error =&gt; console.log(error)) ctx.body = &#123; success: true, data: result &#125; &#125; &#125; 查找数据,并排序 Model.find({}) sort({}) 12345678910const testList = async ctx =&gt; &#123; let result = await Test.find(&#123;&#125;).sort(&#123; createTime: -1 //按创建时间倒排序 &#125;).exec() ctx.body = &#123; success: true, data: result &#125;&#125; 更新数据Model.update({1},{2})1:查找的条件2：修改的选项12345678910111213const update = async ctx =&gt; &#123; let result = await Test.update(&#123; _id: ctx.request.body.id &#125;, &#123; title: ctx.request.body.title, content: ctx.request.body.content, createTime: new Date() &#125;) ctx.body = &#123; success: true, data: result &#125;&#125; upUser.js - 更新数据1234567891011121314function update()&#123; let name = &#123;name:'zhyu'&#125;; let uppassword = &#123;password:"123"&#125;; //直接作用在引入的User User.update(name,uppassword,(err,res)=&gt;&#123; if(res)&#123; console.log('OK:' + res); &#125;else&#123; console.log('ERR:'+ err); &#125; &#125;)&#125;update(); delUser.js - 删除数据123456789101112function deldate() &#123; let del_name = &#123;name: 'zhyu'&#125;; //直接作用在引入的User User.remove(del_name, (err, res) =&gt; &#123; if (res) &#123; console.log('OK:' + res); &#125; else &#123; console.log('ERR:' + err); &#125; &#125;)&#125;deldate(); getUser.js -查找数据123456789101112131415161718function getName()&#123; let get_name = &#123;'name' : 'zhyu'&#125;; //直接作用在引入的User User.find(get_name, function(err, res)&#123; if (res) &#123; if(res === get_name.name)&#123; console.log('Yes') &#125;else&#123; console.log('No') &#125; &#125; else &#123; console.log("Error:" + err); &#125; &#125;)&#125;getName();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[veter报错-修复]]></title>
      <url>%2F2017%2F09%2F22%2Fveter%E6%8A%A5%E9%94%99-%E4%BF%AE%E5%A4%8D%2F</url>
      <content type="text"><![CDATA[报错信息：The Vue Language Server server crashed 5 times in the last 3 minutes. The server will not be restarted.修复：Go to C:\Users\chris\.vscode\extensions\octref.vetur-0.9.3\client\ and run npm install.在相应的根目录下运行npm install]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[url拼接]]></title>
      <url>%2F2017%2F09%2F21%2Furl%E6%8B%BC%E6%8E%A5%2F</url>
      <content type="text"><![CDATA[jsonp url拼接12345678910url += (url.indexOf('?') &lt; 0 ? '?' : '&amp;') + param(data)function param(data) &#123; let url = '' for (var k in data) &#123; let value = data[k] !== undefined ? data[k] : '' url += '&amp;' + k + '=' + encodeURIComponent(value) &#125; return url ? url.substring(1) : ''&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[unix时间转换]]></title>
      <url>%2F2017%2F09%2F19%2Funix%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[关于unix时间转换的api1234567891011121314151617181920212223242526272829303132let http = require('http'), url = require('url')let server = http.createServer((request, response) =&gt; &#123; console.log(`$&#123;request.method&#125; : $&#123;request.url&#125;`); let path = url.parse(request.url).pathname.slice(1) let parseUnix = new Date(path * 1000) let month = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'] let unix = &#123;&#125; let reg = /^\d*$/ if (reg.test(path)) &#123; unix = &#123; "unix": path, "natural": `$&#123;month[parseUnix.getMonth()]&#125; $&#123;parseUnix.getDate()&#125;, $&#123;parseUnix.getFullYear()&#125;` &#125; &#125; else &#123; unix = &#123; "unix": new Date(decodeURI(path)).getTime() / 1000, "natural": decodeURI(path) &#125; &#125; response.writeHead(200, &#123; 'Content-Type': 'text/json' &#125;) response.end(JSON.stringify(unix))&#125;)server.listen(8080)console.log('Server is running at http://127.0.0.1:8080/')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[laravel]]></title>
      <url>%2F2017%2F08%2F31%2Flaravel%2F</url>
      <content type="text"><![CDATA[php框架laravel的基本用法 启动：php artisan serve Migration创建一个迁移数据表： php artisan make:migration create_name_table --create=name根据迁移生成数据表：php artisan migrate撤销返回上一步： php artisan migrate:rollbackMigration数据表：123456789public function up()&#123; Schema::create('name', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;string('name'); $table-&gt;test('content'); $table-&gt;timestamps(); &#125;);&#125; Elopuent生成model: php artisan make:model Name创建的model与创建的表名相同，可以与表相关联 插入数据：打开一个命令行： php artisan tinker然后：$name = new App\Name然后：$name-&gt;name=&#39;zhiyu&#39; // name来源于表结构或者：$name::create([&#39;name&#39;=&gt;&#39;zhiyu&#39;]);然后写入数据库：$name-&gt;save();toArray():$name-&gt;toArray(); //返回一个数组find():$name-&gt;find(1) //查找id为1的数据更新数据：$name-&gt;name=&#39;Anson&#39; -&gt; 再执行 $name-&gt;toArray(); 查找全部数据：123456public function index()&#123; $articles = Article::all(); // return $articles; return view('article',compact('articles'));&#125; 在blade中使用：12345@foreach($articles as $article) &lt;h1&gt; &lt;a href="&#123;&#123;url('article',$article-&gt;id)&#125;&#125;"&gt;&#123;&#123; $article-&gt;title &#125;&#125;&lt;/a&gt; &lt;/h1&gt;@endforeach From1composer require laravelcollective/html 更改config下的app.php1Collective\Html\HtmlServiceProvider::class, 12'Form' =&gt; Collective\Html\FormFacade::class,'Html' =&gt; Collective\Html\HtmlFacade::class, 在model中设置：1protected $fillable = ['title', 'content','_token']; 定义路由：1Route::post('/submitarticle','ArticleController@store'); 数据提交：123456&#123;!! Form::open(['url'=&gt;'/submitarticle']) !!&#125; &lt;h1&gt;创建一个新文章&lt;/h1&gt; &#123;!! Form::text('title',null,['placeholder'=&gt;'文章标题']) !!&#125; &#123;!! Form::textarea('content',null,['placeholder'=&gt;'文章内容']) !!&#125; &#123;!! Form::submit('发布文章') !!&#125;&#123;!! Form::close() !!&#125; post数据接收：1234567public function store(Request $request)&#123; //接收post数据 存入数据库 重定向 $input = $request-&gt;all(); Article::create($input); return redirect('/articles');&#125; 排序：以最新排序12345public function index()&#123; $articles = Article::latest()-&gt;get(); return view('article',compact('articles'));&#125; 坑：注意MySQL端口号12打开MySQL命令行show global variables like 'port'; controller view 返回html文件12345public function login()&#123; \View::addExtension('html','php'); return view('login');&#125; 使用多个数据库1、配置.env文件123456789101112 1 DB_CONNECTION=mysql 2 DB_HOST=127.0.0.1 3 DB_PORT=3306 4 DB_DATABASE=database_name 5 DB_USERNAME=root 6 DB_PASSWORD= 7 8 DB_HOST_CENTER=127.0.0.1 9 DB_PORT_CENTER=330610 DB_DATABASE_CENTER=database_center11 DB_USERNAME_CENTER=root12 DB_PASSWORD_CENTER= 2、配置config/database.php1234567891011121314151617181920212223242526'mysql' =&gt; [ 'driver' =&gt; 'mysql', 'host' =&gt; env('DB_HOST', 'localhost'), 'port' =&gt; env('DB_PORT', '3306'), 'database' =&gt; env('DB_DATABASE', 'forge'), 'username' =&gt; env('DB_USERNAME', 'forge'), 'password' =&gt; env('DB_PASSWORD', ''), 'charset' =&gt; 'utf8', 'collation' =&gt; 'utf8_unicode_ci', 'prefix' =&gt; '', 'strict' =&gt; false, 'engine' =&gt; null,],'mysql_center' =&gt; [ 'driver' =&gt; 'mysql', 'host' =&gt; env('DB_HOST_CENTER', 'localhost'), 'port' =&gt; env('DB_PORT_CENTER', '3306'), 'database' =&gt; env('DB_DATABASE_CENTER', 'forge'), 'username' =&gt; env('DB_USERNAME_CENTER', 'forge'), 'password' =&gt; env('DB_PASSWORD_CENTER', ''), 'charset' =&gt; 'utf8', 'collation' =&gt; 'utf8_unicode_ci', 'prefix' =&gt; '', 'strict' =&gt; false, 'engine' =&gt; null,], 3、创建model123456// 这个model将采用默认的'mysql'连接class UserModel extends Model&#123; // 数据库'database'中的users表 protected $table = "users";&#125; 12345678// 这个model将使用mysql_center连接class UserModel extends Model&#123; // 数据库'dadtabase_center'中的users表 protected $connection = 'mysql_center'; protected $table = "users"; protected $fillable = ['data','updated_at'];&#125; 禁止updated_at和created_at在模型中添加以下:1public $timestamps = false; Mysql乱码：12mysql_query("set character set 'utf8'");//读库 mysql_query("set names 'utf8'");//写库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[史上最偷鸡取巧的计算器]]></title>
      <url>%2F2017%2F07%2F29%2F%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%81%B7%E9%B8%A1%E5%8F%96%E5%B7%A7%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
      <content type="text"><![CDATA[爱咋咋地，我是不会，能实现就是好样的ahhhh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .display &#123; width: 100%; height: 100px; border-bottom: 1px solid #ccc; &#125; .inp, .outp &#123; height: 50%; text-align: right; font-size: 30px; &#125; .inp &#123; color: orangered; &#125; .mian &#123; width: 100%; display: flex; &#125; .inp-btn &#123; border: 1px solid; width: 100%; height: 50px; text-align: center; line-height: 50px; &#125; .zero &#123; width: 200%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="content"&gt; &lt;div class="display"&gt; &lt;div class="inp"&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="outp"&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="mian"&gt; &lt;div class="inp-btn"&gt;7&lt;/div&gt; &lt;div class="inp-btn"&gt;8&lt;/div&gt; &lt;div class="inp-btn"&gt;9&lt;/div&gt; &lt;div class="inp-btn"&gt;*&lt;/div&gt; &lt;/div&gt; &lt;div class="mian"&gt; &lt;div class="inp-btn"&gt;4&lt;/div&gt; &lt;div class="inp-btn"&gt;5&lt;/div&gt; &lt;div class="inp-btn"&gt;6&lt;/div&gt; &lt;div class="inp-btn"&gt;-&lt;/div&gt; &lt;/div&gt; &lt;div class="mian"&gt; &lt;div class="inp-btn"&gt;1&lt;/div&gt; &lt;div class="inp-btn"&gt;2&lt;/div&gt; &lt;div class="inp-btn"&gt;3&lt;/div&gt; &lt;div class="inp-btn"&gt;+&lt;/div&gt; &lt;/div&gt; &lt;div class="mian"&gt; &lt;div class="inp-btn zero"&gt;0&lt;/div&gt; &lt;div class="inp-btn"&gt;.&lt;/div&gt; &lt;div class="inp-btn"&gt;=&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; const disInp = document.querySelector('.inp span') const disOutp = document.querySelector('.outp span') let srt = '' document.querySelectorAll('.inp-btn').forEach(btn =&gt; &#123; btn.addEventListener('click', function (event) &#123; if (btn.innerHTML === '=') &#123; disOutp.innerHTML = eval(srt) srt = eval(srt) &#125; else &#123; srt += btn.innerHTML disInp.innerHTML = srt &#125; &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_Spider_初学]]></title>
      <url>%2F2017%2F07%2F24%2FNode%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6%2F</url>
      <content type="text"><![CDATA[第一次尝试爬虫 ，之前挺好奇的使用的模块：node内置fs,cheerio,rquest爬取网易云部分歌单…在网易云歌单url爬取不到…查看源代码的url可以1234567891011121314151617181920const fs = require('fs')const request = require('request')const cheerio = require('cheerio')request('http://music.163.com/discover/playlist', (err, res, body) =&gt; &#123; err ? console.log(err) : console.log('ok') let $ = cheerio.load(body) let arr = [] $('img[class=j-flag]').each(function (i, elem) &#123; let obj = &#123; img: $(this).attr('src'), title: $('.msk').eq(i).attr('title'), number: $('.nb').eq(i).text(), author: $('.s-fc4').eq(i).next().text(), &#125; arr.push(obj) &#125;) console.log(arr) fs.writeFile('song.json', JSON.stringify(arr), err =&gt; console.log(err))&#125;) 第三版：爬取图片…1234567891011121314151617181920212223242526272829303132333435363738394041const fs = require('fs')const request = require('request')const cheerio = require('cheerio')let arr = []for (let i = 0; i &lt; 11; i++) &#123; let url = `http://www.jianshu.com/trending/monthly?&amp;page=$&#123;i&#125;` request(url, (error, response, body) =&gt; &#123; let $ = cheerio.load(body) let title = $('.title') title.each(function (index, elem) &#123; let author = $('.blue-link').eq(index).text() let img = $('.wrap-img').eq(index).find('img').attr('src') let title = &#123; title: $(this).text().trim(), author: author, src: $(this).attr('href'), index: i + '-' + index, img: img &#125; arr.push(title) // console.log(title) &#125;) fs.writeFile('./data/dir.txt', JSON.stringify(arr), error =&gt; error ? console.log(error) : console.log(url + ': 目录写入')) arr.forEach(i =&gt; request('http://www.jianshu.com' + i.src, function (error, response, body) &#123; // you need to judge if (body) &#123; let $ = cheerio.load(body) let text = $('.show-content').text() fs.writeFile('./data/text_' + i.index + '.txt', text, err =&gt; err ? console.log(err) : console.log('ok: ', i.title)) &#125; &#125;) ) arr.forEach(i =&gt; &#123; if (i.img) &#123; request('http:' + i.img).pipe(fs.createWriteStream(`./data/img/$&#123;i.index&#125;.jpg`)) &#125; &#125;) &#125;)&#125; 第二版：改进只能抓取20条的缺陷…从chrome找到分页请求 循环url123456789101112131415161718192021222324252627282930313233const fs = require('fs')const request = require('request')const cheerio = require('cheerio')let arr = []for (let i = 0; i &lt; 11; i++) &#123; let url = `http://www.jianshu.com/trending/monthly?&amp;page=$&#123;i&#125;` request(url, (error, response, body) =&gt; &#123; let $ = cheerio.load(body) let title = $('.title') title.each(function (index, elem) &#123; let author = $('.blue-link').eq(i).text() let title = &#123; title: $(this).text().trim(), author: author, src: $(this).attr('href'), index: i + '-' + index &#125; arr.push(title) &#125;) fs.writeFile('./data/dir.txt', JSON.stringify(arr), error =&gt; error ? console.log(error) : console.log(url + ': 目录写入')) arr.forEach(i =&gt; request('http://www.jianshu.com' + i.src, function (error, response, body) &#123; // you need to judge if (body) &#123; let $ = cheerio.load(body) let text = $('.show-content').text() fs.writeFile('./data/text_' + i.index + '.txt', text, err =&gt; err ? console.log(err) : console.log('ok: ', i.title)) &#125; &#125;) ) &#125;)&#125; 初版：123456789101112131415161718192021222324252627282930313233const fs = require('fs')const request = require('request');const cheerio = require('cheerio')function spider(url) &#123; request(url, function (error, response, body) &#123; console.log('error:', error) console.log('statusCode:', response &amp;&amp; response.statusCode) let $ = cheerio.load(body) let arr = [] $('.title').each(function (i, elem) &#123; let author = $('.blue-link').eq(i).text() arr[i] = &#123; title: $(this).text().trim(), author: author, src: $(this).attr('href'), index: i &#125; &#125;) arr.splice(arr.length - 1, 1) fs.writeFile('./data/dir.txt', JSON.stringify(arr), err =&gt; err ? console.log(err) : console.log('ok')) arr.forEach(i =&gt; request('http://www.jianshu.com' + i.src, function (error, response, body) &#123; let $ = cheerio.load(body) let text = $('.show-content').text() fs.writeFile('./data/text_' + i.index + '.txt', text, err =&gt; err ? console.log(err) : console.log('ok: ', i.title)) &#125;) ) &#125;)&#125;spider('http://www.jianshu.com/')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[koa性能优化]]></title>
      <url>%2F2017%2F07%2F19%2Fkoa%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue过度效果配合annimate.css]]></title>
      <url>%2F2017%2F07%2F05%2Fvue%E8%BF%87%E5%BA%A6%E6%95%88%E6%9E%9C%E9%85%8D%E5%90%88annimate-css%2F</url>
      <content type="text"><![CDATA[只有一个运动元素使用transition标签enter-active-class 进入样式leave-active-class 离开样式123456p &#123; width: 100px; height: 100px; background: palegreen; margin: 10px auto;&#125; 123456789&lt;div id="app"&gt; &lt;button type="button" @click="show=!show"&gt;过度效果&lt;/button&gt; &lt;transition enter-active-class="zoomInLeft" leave-active-class="bounceOutRight" &gt; &lt;p v-if="show" class="animated"&gt;&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 12345678new Vue(&#123; el: '#app', data() &#123; return &#123; show: true &#125; &#125;&#125;) 有多个运动元素使用transition-group标签,并且把运动元素绑定相对应的key值12345678910&lt;div id="app"&gt; &lt;button type="button" @click="show=!show"&gt;过度效果&lt;/button&gt; &lt;transition-group enter-active-class="zoomInLeft" leave-active-class="bounceOutRight" &gt; &lt;p v-if="show" class="animated" :key="0"&gt;&lt;/p&gt; &lt;p v-if="show" class="animated" :key="1"&gt;&lt;/p&gt; &lt;/transition-group&gt;&lt;/div&gt; 12345678new Vue(&#123; el: '#app', data() &#123; return &#123; show: true &#125; &#125;&#125;) 列表循环computed 实时监听数据,必须要有返回值12345678&lt;div id="app"&gt; &lt;input type="text" v-model="input"&gt; &lt;transition-group enter-active-class="zoomInLeft" leave-active-class="bounceOutRight"&gt; &lt;p class="animated" v-for="(item,index) in lists" :key="index" v-if="show"&gt; &#123;&#123;item&#125;&#125; &lt;/p&gt; &lt;/transition-group&gt;&lt;/div&gt; 1234567891011121314151617181920212223new Vue(&#123; el: '#app', data() &#123; return &#123; input: '', list: ['apple', 'banana', 'orange', 'pear'] &#125; &#125;, computed: &#123; lists() &#123; let arr = [] this.list.forEach((el) =&gt; &#123; if (el.includes(this.input)) &#123; arr.push(el) &#125; &#125;) return arr &#125;, show()&#123; return this.input ? this.show = true : this.show = false &#125; &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue组件]]></title>
      <url>%2F2017%2F07%2F02%2Fvue%E7%BB%84%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[必须在vue实例之前创建 全局组件123&lt;div id="example"&gt; &lt;my-conponent&gt;&lt;/my-conponent&gt;&lt;/div&gt; 12345678&lt;script&gt; Vue.component("my-conponent", &#123; template: `&lt;div&gt;这是一个全局组件&lt;/div&gt;` &#125;) new Vue(&#123; el:'#example', &#125;) 局部组件123&lt;div id="example"&gt; &lt;my-conponent-b&gt;&lt;/my-conponent-b&gt;&lt;/div&gt; 12345678910&lt;script&gt;const Child = &#123; template: `&lt;div&gt;这是一个局部组件&lt;/div&gt;` &#125;new Vue(&#123; el: '#example', components: &#123; 'my-conponent-b': Child &#125;&#125;)&lt;/script&gt; 动态组件12345&lt;div id="example"&gt; &lt;button type="botton" @click="isa()"&gt;组件a&lt;/button&gt; &lt;button type="botton" @click="isb()"&gt;组件b&lt;/button&gt; &lt;component :is="isis"&gt;&lt;/component&gt;&lt;/div&gt; 1234567891011121314151617181920212223Vue.component("my-conponent-a", &#123; template: `&lt;div"&gt;组件a&lt;/div&gt;`&#125;)Vue.component("my-conponent-b", &#123; template: `&lt;div"&gt;组件b&lt;/div&gt;`&#125;)new Vue(&#123; el: '#example', data() &#123; return &#123; isis: 'my-conponent-a' &#125; &#125;, methods: &#123; isa() &#123; this.isis = 'my-conponent-a' &#125;, isb() &#123; this.isis = 'my-conponent-b' &#125; &#125;&#125;) x-templatevue似乎不推荐这莫使用1234567&lt;div id="example"&gt; &lt;my-conponent-a&gt;&lt;/my-conponent-a&gt;&lt;/div&gt;&lt;template id="my-conponent-a"&gt; &lt;div&gt;这是一个组件&lt;/div&gt;&lt;/template&gt; 1234567Vue.component("my-conponent-a", &#123; template: '#my-conponent-a'&#125;)new Vue(&#123; el: '#example'&#125;) 组件通信父组件向子组件传值1.在父组件中给子组件标签绑定父组件数据1&lt;my-conponent-a-b :data="counter"&gt;&lt;/my-conponent-a-b&gt; 2.在子组件中使用props: [String]接受值3.在子组件中使用绑定的属性名称123&lt;div id="example"&gt; &lt;my-conponent-a&gt;&lt;/my-conponent-a&gt;&lt;/div&gt; 12345678910111213141516171819202122232425Vue.component("my-conponent-a", &#123; template: ` &lt;div @click="counter+=1"&gt; &lt;p&gt;这是一个父组件 -&gt; &#123;&#123;counter&#125;&#125;&lt;/p&gt; &lt;my-conponent-a-b :data="counter"&gt;&lt;/my-conponent-a-b&gt; &lt;/div&gt; `, components: &#123; 'my-conponent-a-b': &#123; props: ['data'], template: ` &lt;p&gt;这是一个子组件 -&gt; &#123;&#123;data&#125;&#125;&lt;/p&gt; ` &#125; &#125;, data() &#123; return &#123; counter: 0 &#125; &#125;&#125;)new Vue(&#123; el: '#example'&#125;) 子组件向父组件通信由子组件主动发送数据1.在子组件使用点击事件发送数据vm.$emit(事件名,数据)2.在父组件使用子组件发送的事件名为自定义事件@… 在方法中使用参数接收数据123&lt;div id="example"&gt; &lt;my-conponent-a&gt;&lt;/my-conponent-a&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344Vue.component("my-conponent-a", &#123; template: ` &lt;div&gt; &lt;p&gt;父组件 -&gt; &#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;my-conponent-a-b @childMsg="getData"&gt;&lt;/my-conponent-a-b&gt; &lt;/div&gt; `, data() &#123; return &#123; msg: ' 我是父组件数据' &#125; &#125;, methods: &#123; getData(data) &#123; this.msg = data &#125; &#125;, components: &#123; 'my-conponent-a-b': &#123; template: ` &lt;div&gt; &lt;p&gt;子组件 -&gt; &#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;button @click="sendMsg()"&gt;发送数据&lt;/button&gt; &lt;/div&gt; `, data() &#123; return &#123; msg: '我是子组件数据' &#125; &#125;, methods: &#123; sendMsg() &#123; this.$emit('childMsg', this.msg) &#125; &#125; &#125; &#125;&#125;)new Vue(&#123; el: '#example', data() &#123; return &#123;&#125; &#125;&#125;) 子组件更改数据父组件同步更改1.使用.sync修饰符 vue版本最低为2.31234&lt;div id="app"&gt; &lt;h2&gt;父组件 -&gt; &#123;&#123;msg&#125;&#125;&lt;/h2&gt; &lt;my-component :data.sync="msg"&gt;&lt;/my-component&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627const myCom = &#123; template: `&lt;div&gt; 子组件 -&gt; &#123;&#123;data&#125;&#125; &lt;button @click="change"&gt;改变数据&lt;/button&gt; &lt;/div&gt;`, props: ['data'], data() &#123; return &#123; msg: '改变数据' &#125; &#125;, methods: &#123; change() &#123; this.$emit('update:data',this.msg) &#125; &#125;&#125;const app = new Vue(&#123; data() &#123; return &#123; msg: '父组件数据' &#125; &#125;, components: &#123; 'my-component': myCom &#125;&#125;).$mount('#app') 2.父级传递给子集的为一个对象，改变对象的引用即可1234&lt;div id="app"&gt; &lt;h2&gt;父组件 -&gt; &#123;&#123;msg.a&#125;&#125;&lt;/h2&gt; &lt;my-component :data.sync="msg"&gt;&lt;/my-component&gt;&lt;/div&gt; 123456789101112131415161718192021222324const myCom = &#123; template: `&lt;div&gt; 子组件 -&gt; &#123;&#123;data.a&#125;&#125; &lt;button @click="change"&gt;改变数据&lt;/button&gt; &lt;/div&gt;`, props: ['data'], methods: &#123; change() &#123; this.data.a = 'aaa' &#125; &#125;&#125;const app = new Vue(&#123; data() &#123; return &#123; msg: &#123; a: '父组件数据' &#125; &#125; &#125;, components: &#123; 'my-component': myCom &#125;&#125;).$mount('#app') 非父子组件通信用一个空的vue实例来作为中央数据总线:1const bus = new Vue() 12//在需要发送数据的组件触发事件bus.$emit('data', this.data) 1234//在接收的组件中创建钩子中的监听事件bus.$on('data', (data) =&gt; &#123; this.data = data&#125;) 示例：12345&lt;div id="app"&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;component-b&gt;&lt;/component-b&gt; &lt;component-c&gt;&lt;/component-c&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const bus = new Vue()const componentA = &#123; template: ` &lt;div&gt; 组件a -&gt; &#123;&#123;dataA&#125;&#125; &lt;button @click="seng"&gt;向C发送数据&lt;/button&gt; &lt;/div&gt; `, data() &#123; return &#123; dataA: '数据-a' &#125; &#125;, methods: &#123; seng() &#123; bus.$emit('a-data', this.dataA) &#125; &#125;&#125;const componentB = &#123; template: ` &lt;div&gt; 组件b -&gt; &#123;&#123;dataB&#125;&#125; &lt;button @click="seng"&gt;向C发送数据&lt;/button&gt; &lt;/div&gt; `, data() &#123; return &#123; dataB: '数据-b' &#125; &#125;, methods: &#123; seng() &#123; bus.$emit('b-data', this.dataB) &#125; &#125;&#125;const componentC = &#123; template: ` &lt;div&gt; 组件c -&gt; 接收的数据： a:&#123;&#123;dataA&#125;&#125; b:&#123;&#123;dataB&#125;&#125; &lt;/div&gt; `, data() &#123; return &#123; dataA: '', dataB: '' &#125; &#125;, mounted() &#123; //this指向 //1.使用箭头函数绑定this bus.$on('a-data', (data) =&gt; &#123; console.log(data) this.dataA = data &#125;) //2.使用bind绑定this bus.$on('b-data', function (data) &#123; console.log(data) this.dataB = data &#125;.bind(this)) //3.使用 let _this = this &#125;&#125;new Vue(&#123; components: &#123; 'component-a': componentA, 'component-b': componentB, 'component-c': componentC &#125;&#125;).$mount('#app')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue自定义指令]]></title>
      <url>%2F2017%2F06%2F30%2Fvue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[自定义过滤器和自定义指令一定要写在vue实例之前 自定义过滤器123Vue.filter('a', input =&gt; &#123; return '$'+input;&#125;) 1&lt;li v-for="v in myData"&gt;&#123;&#123;v | a&#125;&#125;&lt;/li&gt; 自定义指令：实现拖拽功能123456789101112131415161718192021Vue.directive('drag', &#123; inserted: function (el,binding) &#123; el.style.position = 'absolute'; el.style.left = `$&#123;binding.value.left&#125;px`; el.style.top = `$&#123;binding.value.top&#125;px`; el.onmousedown = function (ev) &#123; let disX = ev.clientX - el.offsetLeft; let disY = ev.clientY - el.offsetTop; document.onmousemove = function (ev) &#123; let left = ev.clientX - disX; let top = ev.clientY - disY; el.style.left = `$&#123;left&#125;px`; el.style.top = `$&#123;top&#125;px`; &#125; document.onmouseup = function (ev) &#123; document.onmousemove = null; document.onmouseup = null; &#125; &#125; &#125;&#125;) 12&lt;div class="box" v-drag="&#123;left:0,top:200&#125;"&gt;&lt;/div&gt;&lt;div class="box" v-drag="&#123;left:500,top:200&#125;"&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown编辑器]]></title>
      <url>%2F2017%2F06%2F04%2FMarkdown%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
      <content type="text"><![CDATA[多学一点总是没错的Markdown编辑器：SimpleMDEMarkdown语法解析：marked代码语法高亮：highlight 实例：引入样式：12&lt;link rel="stylesheet" href="./dist/simplemde.min.css"&gt;&lt;link rel="stylesheet" href="./highlight/styles/default.css"&gt; 引入js：123&lt;script src="./dist/simplemde.min.js"&gt;&lt;/script&gt;&lt;script src="./node_modules/marked/lib/marked.js"&gt;&lt;/script&gt;&lt;script src="./highlight/highlight.pack.js"&gt;&lt;/script&gt; html：123&lt;input type="textarea " name="" id="mde" value=""&gt;&lt;button type="" id="sub"&gt;show&lt;/button&gt;&lt;div id="content"&gt;&lt;/div&gt; JavaScript:1234567891011121314151617181920212223242526 let simplemde = new SimpleMDE(&#123; element: document.getElementById('mde') &#125;); let renderer = new marked.Renderer(); marked.setOptions(&#123; renderer: renderer, gfm: true, pedantic: false, sanitize: false, tables: true, breaks: true, smartLists: true, smartypants: true, highlight: function (code) &#123; return hljs.highlightAuto(code).value; &#125; &#125;); document.getElementById('sub').addEventListener('click', function () &#123; console.log(simplemde.value()); document.getElementById('content').innerHTML = marked(simplemde.value()); &#125;); hljs.initHighlightingOnLoad();&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Koa参看资料]]></title>
      <url>%2F2017%2F06%2F02%2FKoa%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%2F</url>
      <content type="text"><![CDATA[重在积累Koa基本用法参考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node和图灵机器人]]></title>
      <url>%2F2017%2F06%2F01%2FNode%E5%92%8C%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[一点都不会，我要学习Node了 turing.js12345678910111213141516171819202122const http = require('http');const getMessage = function (info, callback) &#123; let key = '图灵官网key', url = 'http://www.tuling123.com/openapi/api?key=' + key + 'info=' + info, req = http.get(url, function (res) &#123; let body = ''; console.log("Got response: " + res.statusCode); res.on('data', function (data) &#123; body += data; &#125;).on('end', function () &#123; console.log(res.headers); console.log(body); callback(JSON.parse(body)["text"]); &#125;); &#125;).on('error', function (e) &#123; console.log("Got error: " + e.message); &#125;); req.end();&#125;module.exports.getMessage = getMessage; app.js123456789101112131415const http = require('http'), url = require('url'), turing = require('./turing');http.createServer((request, response) =&gt; &#123; let msg = url.parse(request.url).pathname; turing.getMessage(msg, data =&gt; &#123; var html = "&lt;h1&gt;" + data + "&lt;/h1&gt;"; response.writeHead(200, &#123; "Content-Type": "text/html;charset=utf-8" &#125;); response.write(html); response.end(); &#125;);&#125;).listen(8080);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[php与MongoDB]]></title>
      <url>%2F2017%2F06%2F01%2Fphp%E4%B8%8EMongoDB%2F</url>
      <content type="text"><![CDATA[启动mongoDB数据库 : mongod –dbpath D:mongo\data\db(数据库文件路径) 基本操作：1234567891011121314151617181920212223242526&lt;?php$m = new MongoClient(); // 连接默认主机和端口为：mongodb://localhost:27017$db = $m-&gt;anson; // 获取名称为 "anson" 的数据库,没有则创建$collection = $db-&gt;anson; // 选择集合,没有则创建//获取提交数据$userName = $_POST['username'];$userPassword = $_POST['password'];//插入数据$document = array( "name" =&gt; "$userName", "passwords" =&gt; "$userPassword");$collection-&gt;insert($document);echo "数据插入成功 &lt;br&gt;";//查询数据$query = array( "name" =&gt; "$userName" );if($cursor = $collection-&gt;find($query))&#123; echo $document["name"]."&lt;br&gt;"; echo $document["passwords"]; &#125;?&gt; 补充：提交数据12345678910111213141516171819&lt;?php$m = new MongoClient(); // 连接默认主机和端口为：mongodb://localhost:27017$db = $m-&gt;anson; // 获取名称为 "anson" 的数据库,没有则创建$collection = $db-&gt;anson; // 选择集合,没有则创建//获取提交数据$userName = $_POST['name'];$userPassword = $_POST['pas'];//插入数据$document = array( "name" =&gt; "$userName", "passwords" =&gt; "$userPassword");//向数据库提交账号信息$collection-&gt;insert($document);echo "账号注册成功 ";?&gt; 查询数据1234567891011121314151617181920212223242526272829303132333435363738&lt;?php$m = new MongoClient(); // 连接默认主机和端口为：mongodb://localhost:27017$db = $m-&gt;anson; // 获取名称为 "anson" 的数据库,没有则创建$collection = $db-&gt;anson; // 选择anson集合,没有则创建$name = $_POST['name']; // 获取form表单的用户名$password = $_POST['pas']; // 获取form表单的密码//查询格式$document = array( "name" =&gt; $name);//向数据库提交查找$cursor = $collection-&gt;find($document);//查找数据总数 如果为0则用户不存在$cursor2 = $collection-&gt;find($document)-&gt;count();//条件判断 如果不等于0则：if($cursor2 != 0)&#123; //遍历循环查找过来数据 foreach ($cursor as $documents) &#123; //如果名字等于用户的名字 if($documents["name"] == $name)&#123; //并且密码也等于 则账号正确 if($documents["passwords"] == $password)&#123; echo "账号正确"; &#125;else&#123; //否则密码错误 echo "密码错误"; &#125; &#125; &#125;&#125;else&#123; //如果等于0用户不存在 echo "用户名不存在"; &#125;?&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue+Koa+MongoDB]]></title>
      <url>%2F2017%2F05%2F31%2Fvue-koa-MongoDB%2F</url>
      <content type="text"><![CDATA[重写于17年7月7/8/10日参考教程 问题汇总Vue打包1npm run build 打包之后是无法直接打开，需要放到服务器环境:node服务器：1.使用koa生成器：1koa2 demo &amp;&amp; cd demo &amp;&amp; npm i 2.将打包文件index.html复制到views下 将ststic文件夹下的文件夹复制到public下3.修改index.html的js和css文件路径，如：1&lt;link href=/static/css/app.813a0c4380ae8d8063d6247ed0985f66.css rel=stylesheet&gt; 修改为：1&lt;link href=css/app.813a0c4380ae8d8063d6247ed0985f66.css rel=stylesheet&gt; 4.运行命令，启动服务：1npm start 5.如果开启history模式则不能正确跳转，需要服务端配置支持HTML5 History Mode6.使用pm2：1npm prd Ajax使用vue官方推荐的axios1.下载axios和vue-axios2.在main.js中注册使用12345// scr/main.jsimport VueAxios from 'vue-axios'import axios from 'axios'Vue.use(VueAxios,axios) 3.使用方法：1234// 1.this.$http.get().then().catch// 2.this.axios.get().then().catch 不推荐1Vue.prototype.$http = Axios 跨域问题由于页面使用vue-cli 端口默认为8080，而koa的端口为3000，所以存在跨域问题解决办法:1.koa使用koa的跨域模块： koa1的为： koa-cors koa2的为： koa2-cors推荐使用koa2的跨域模块，koa1似乎不怎么好用2.在vue项目中找到webpack配置文件夹config的index.js 修改proxyTable ,添加如下内容：1234'/user': &#123; target: 'http://localhost:3000', changeOrigin: true&#125; 这样配置/user 相当于http://localhost:3000/user这样看起来像是同源的…在项目打包以后放到koa下面时就时同源的啦 vue设置导航拦截123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import Vue from 'vue'import Router from 'vue-router'import Hello from '@/components/Hello'import Login from '../components/Login.vue'import TodoList from '../components/TodoList.vue'import Register from '../components/register.vue'Vue.use(Router)const router = new Router(&#123; routes: [&#123; path: '/', name: 'login', component: Login &#125;, &#123; path: '/todolist', name: 'todolist', component: TodoList &#125;, &#123; path: '/register', name: 'register', component: Register &#125; ]&#125;)router.beforeEach((to, from, next) =&gt; &#123; const token = sessionStorage.getItem('demo-token') //如果起始页时登录或注册则继续 if (to.path == '/' || to.path == '/register') &#123; //如果在登录界面token不为空则跳转todolist if (token != 'null' &amp;&amp; token != null) &#123; next('/todolist') &#125; next() &#125; else &#123; //如果token不为空则继续，否则跳回登录界面 if (token != 'null' &amp;&amp; token != null) &#123; Vue.prototype.$http.defaults.headers.common['Authorization'] = 'Bearer ' + token next() &#125; else &#123; next('/') &#125; &#125;&#125;)export default router JsonWebTokenkoa jwt demo 1.下载node.js的jsonwebtoken模块1npm i jsonwebtoken -S 2.生成token12345678910const content = &#123; //通过数据库查找过来的数据 id: userData[0]._id&#125;//签名const secret = 'vueAndKoa2-demo2'//生成token密钥const token = jwt.sign(content, secret, &#123; expiresIn: 60 * 2 //过期时间&#125;) 3.使用koa-jwt验证签发密钥1npm i koa-jwt -S 3.0 koa-jwt需要检查请求的herder中的Authorization属性是否有Bearer在vue导航钩子中定义(回看vue设置导航拦截)：Bearer 后面有一个空格1Vue.prototype.$http.defaults.headers.common['Authorization'] = 'Bearer ' + token 以下操作都在app.js 3.1 自定义40112345678910111213141516app.use(async(ctx, next) =&gt; &#123; const start = new Date() const ms = new Date() - start console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`) return await next().catch((err) =&gt; &#123; if (401 == err.status) &#123; ctx.state = 401 ctx.body = &#123; info: 'No-401', success: false &#125; &#125; else &#123; throw err &#125; &#125;)&#125;) 3.2 使用koa-jwt签名要一致 unless不包含使用user的路由123app.use(koaJwt(&#123; secret: 'vueAndKoa2-demo2'&#125;).unless(&#123;path:[/^\/user/]&#125;)) 3.3 定义使用koa-jwt的路由123456app.use(async ctx =&gt; &#123; console.log(`Url:::$&#123;ctx.url&#125;`) if (ctx.url.match(/^\/api/)) &#123; ctx.body = 'ok' &#125;&#125;) 3.4 在api下的路由使用ctx.state.user 接收数据123const getStateUser = async(ctx, next) =&gt; &#123; ctx.body = ctx.state.user&#125; 如果正常，数据如下1&#123;id: "595e0bacef26c9282c9f3c22", iat: 1499565654, exp: 1499565774&#125; 如果token过期则返回401信息 3.5 使用vue-auth1npm i vue-auth -S 配置如下：12345Vue.use(VueAuth, &#123; stroagePrefix: '_prefix', authPath:'/', //过期跳转 redirectType: 'router'&#125;) 3.6 不完整前端验证token思路1.在vue的登录页面中使用created钩子函数检查token 如果token没有过期自动跳转todolist 如果token过期则返回401信息，401信息为之前自定义的401信息12345678910111213141516171819202122created() &#123; // 自定义的获取koa-jwt生成的ctx.state.user数据 // 数据格式为：&#123;id: "595e0bacef26c9282c9f3c22", iat: 1499565654, exp: 1499565774&#125; // iat 生成的秒数时间戳 exp过期的秒数时间戳 this.$http.post('/api/token') .then(res =&gt; &#123; console.log(res.data) if (res.data.exp) &#123; const exp = res.data.exp const now = Math.ceil(new Date().getTime() / 1000) if (now - exp &gt;= 0) &#123; console.log(now - exp) this.$router.push('/todolist') &#125; else &#123; this.$router.push('/') &#125; &#125; else if (res.data.success) &#123; this.$router.push('/') &#125; &#125;) .catch(err =&gt; console.log(err))&#125; 2.前端登录方法,密码使用md5加密 发送数据，生成token，并使用vue-auth保存在localstorage 跳转页面123456789101112131415161718192021222324252627282930login() &#123; localStorage.setItem('username', this.account) let data = &#123; name: this.account, pass: md5(this.password) &#125; this.$http.post('/user/find', data) .then(res =&gt; &#123; if (res.data.success) &#123; this.$auth.setToken(res.data.info) this.$router.push('/todolist') this.$message(&#123; type: 'success', message: '登录成功' &#125;) &#125; else &#123; this.$message(&#123; type: 'error', message: res.data.info &#125;) this.$auth.removeToken() &#125; &#125;) .catch(err =&gt; &#123; this.$message(&#123; type: 'error', message: '请求错误' &#125;) &#125;)&#125; 3.1在跳转过来的todolist页面使用created钩子函数检查token1234567891011created() &#123; this.$http.post('/api/token') .then(res =&gt; &#123; if (res.data.success == false) &#123; this.$auth.removeToken() this.$message.error('登录过期') this.$router.push('/') &#125; &#125;) .catch(err =&gt; console.log(err))&#125; 3.2在todolist页面使用updated钩子函数 只要用户有操作就更新token，使其保持登录状态(后端根据传过来的用户名检查用户是否合法) 如果用户超过token有效时间，再操作就返回首页，提示用户信息123456789101112131415161718192021222324updated() &#123; //检查token是否存在 不存在直接返回登录 const token = localStorage.getItem('_auth.token') const username = localStorage.getItem('username') if (token != 'null' &amp;&amp; token != null) &#123; if (username) &#123; this.$http.post('/api/uptoken', &#123; name: username &#125;) .then(res =&gt; &#123; if (res.data.token) &#123; console.log(res.data) this.$auth.setToken(res.data.token) &#125; &#125;) &#125; console.log(this.$auth.isAuthenticated()) if (this.$auth.isAuthenticated() == false) &#123; this.$router.push('/') this.$message.error('登录过期') &#125; &#125; else &#123; this.$router.push('/') this.$message.error('token无效') &#125;&#125; 3.7 完整的app.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const Koa = require('koa')const app = new Koa()const views = require('koa-views')const json = require('koa-json')const onerror = require('koa-onerror')const bodyparser = require('koa-bodyparser')const logger = require('koa-logger')const cors = require('koa2-cors')const koaJwt = require('koa-jwt')const index = require('./routes/index')const users = require('./routes/users')const api = require('./routes/api')// error handleronerror(app)// middlewaresapp.use(bodyparser(&#123; enableTypes: ['json', 'form', 'text']&#125;))app.use(cors())app.use(json())app.use(logger())app.use(require('koa-static')(__dirname + '/public'))app.use(views(__dirname + '/views', &#123; extension: 'html'&#125;))// loggerapp.use(async(ctx, next) =&gt; &#123; const start = new Date() const ms = new Date() - start console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`) return await next().catch((err) =&gt; &#123; if (401 == err.status) &#123; ctx.state = 401 ctx.body = &#123; info: 'No-401', success: false &#125; &#125; else &#123; throw err &#125; &#125;)&#125;)//koa-jwtapp.use(koaJwt(&#123; secret: 'vueAndKoa2-demo2'&#125;).unless(&#123;path:[/^\/user/]&#125;))// routersapp.use(index.routes(), index.allowedMethods())app.use(users.routes(), users.allowedMethods())app.use(api.routes(), api.allowedMethods())//使用koa-jwt的路由app.use(async ctx =&gt; &#123; console.log(`Url:::$&#123;ctx.url&#125;`) if (ctx.url.match(/^\/api/)) &#123; ctx.body = 'ok' &#125;&#125;)module.exports = app 似乎koa-jwt注册要在router注册之前 ，监察路由需要在router注册之后 以下内容为最初版部分... Vue页面:12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;info&#125;&#125;&lt;/h1&gt; &lt;input type="text" v-model="name"&gt; &lt;input type="password" v-model="password" @keyup.enter.native="login()"&gt; &lt;button type="submit" @click="login()"&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; name: '', password: '', info:'' &#125; &#125;, methods: &#123; login() &#123; let obj = &#123; name: this.name, password: this.password &#125; this.$http.post(`http://localhost:8889/user`, obj) .then(response =&gt; &#123; if (response.data.success) &#123; this.info = response.data.info &#125;else&#123; this.info = response.data.info &#125; &#125;) .catch(err =&gt; console.log(err)); &#125; &#125;&#125;&lt;/script&gt; 后端程序:12345├── server // Koa后端，用于提供Api ├── app.js // 入口文件 ├── db.js // 连接数据库 提供数据库api ├── controller.js // controller-控制器 └── router.js // route-路由 app.js123456789101112131415const Koa = require('koa'), router = require('koa-router')(), auth = require('./server/router'), cors = require('koa-cors')//koa跨域模块const app = new Koa()app.use(cors())app.use(require('koa-bodyparser')());//post解析app.use(router.routes())router.use(auth.routes());//注册router.js文件app.listen(8888, () =&gt; &#123; console.log('koa runing at 8888 port')&#125;) db.js123456789101112131415161718192021222324const db = require('monk')('localhost/mydb') db.then(() =&gt; console.log('Connected correctly to server'))const users = db.get('document')//查找账户apiconst getUserByName = async user_name =&gt; &#123; let info = await users.find(&#123; name: user_name &#125;).then(res =&gt; res) return info&#125;//添加账户apiconst postAuth = async(user_name, user_password) =&gt; &#123; await users.insert(&#123; name: user_name, password: user_password &#125;).then(res =&gt; console.log('User OK')).cahct(err =&gt; console.log(err))&#125;module.exports =&#123; getUserByName, postAuth&#125; controller.js12345678910111213141516171819202122232425262728const user = require('./db')const getUserInfo = async content =&gt; &#123; const userInfo = content.request.body const userAuth = await user.getUserByName(userInfo.name) console.log(userAuth) //数据库在查找为空时返回空 if (userAuth != "") &#123; if (userAuth[0].password != userInfo.password) &#123; content.body = &#123; success: false, info: "密码错误" &#125; &#125; else &#123; content.body = &#123; success: true, info: "账户正确" &#125; &#125; &#125; else &#123; content.body = &#123; success: false, info: "用户不存在" &#125; &#125;&#125;module.exports = getUserInfo router.js123456const router = require('koa-router')()const auth = require('./controller')router.post('/user',auth.getUserInfo)module.exports = router]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node框架Koa处理URL]]></title>
      <url>%2F2017%2F05%2F28%2FNode%E6%A1%86%E6%9E%B6Koa%E5%A4%84%E7%90%86URL%2F</url>
      <content type="text"><![CDATA[引入koa-router这个中间件,让它负责处理URL映射 安装koa-router:1npm i koa-router 处理GET请求:使用router.get(&#39;/path&#39;, async fn)来注册一个GET请求。可以在请求路径中使用带变量的/hello/:name，变量可以通过ctx.params.name访问。12345678910111213141516171819202122const Koa = require('Koa');//函数调用 koa-router() :const router = require('Koa-router')();const app = new Koa();app.use(async(ctx, next) =&gt; &#123; console.log(`method: $&#123;ctx.method&#125;; url: $&#123;ctx.request.url&#125;`); await next();&#125;)//注册koa-router中间件app.use(router.routes());router.get('/', async(ctx, name) =&gt; &#123; ctx.response.body = '&lt;h1&gt;Index&lt;/h1&gt;';&#125;)router.get('/hello/:name', async(ctx, next) =&gt; &#123; let name = ctx.params.name; ctx.response.body = `&lt;h1&gt;Hello,$&#123;name&#125;&lt;/h1&gt;`;&#125;)app.listen(8080);console.log('app started at port 8080...'); 处理POST请求:使用router.post(&#39;/path&#39;, async fn)来注册一个POST请求。 坑：用post请求处理URL时，会遇到一个问题：post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能！ 解决办法：引入koa-bodyparser中间件:1npm i koa-bodyparser 由于中间件的顺序很重要，这个koa-bodyparser必须在router之前被注册到app对象上。12const bodyParser = require('koa-bodyparser');app.use(bodyParser()); post示例：12345678910111213141516171819202122232425262728293031323334353637const Koa = require('Koa');const router = require('Koa-router')();const bodyParser = require('koa-bodyparser');const app = new Koa();app.use(async(ctx, next) =&gt; &#123; console.log(`method: $&#123;ctx.method&#125;; url: $&#123;ctx.request.url&#125;`); await next();&#125;)//注册koa-bodyparser中间件app.use(bodyParser());//注册koa-router中间件app.use(router.routes());router.get('/', async(ctx, name) =&gt; &#123; ctx.response.body = `&lt;h1&gt;Index&lt;/h1&gt; &lt;form action="/signin" method="post"&gt; &lt;p&gt;Name: &lt;input name="name" value="koa"&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;input name="password" type="password"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="Submit"&gt;&lt;/p&gt; &lt;/form&gt;`;&#125;)router.post('/signin', async(ctx, next) =&gt; &#123; let name = ctx.request.body.name || '', password = ctx.request.body.password || ''; console.log(`name: $&#123;name&#125; ; password: $&#123;password&#125;`); if (name === 'koa' &amp;&amp; password === '12345') &#123; ctx.response.body = `&lt;h1&gt;Welcome, $&#123;name&#125;!&lt;/h1&gt;`; &#125; else &#123; ctx.response.body = `&lt;h1&gt;Login failed!&lt;/h1&gt; &lt;p&gt;&lt;a href="/"&gt;Try again&lt;/a&gt;&lt;/p&gt;`; &#125;&#125;)app.listen(8080);console.log('app started at port 8080...'); 通过let name = ctx.request.body.name拿到表单的name字段。类似的，put、delete、head请求也可以由router处理。 重构:把URL处理函数集中到某个js文件，或者某几个js文件中就好了，然后让app.js自动导入所有处理URL的函数12345678910111213141516171819koa工程项目/|+- .vscode/| || +- launch.json &lt;-- VSCode 配置文件|+- controllers/| || +- login.js &lt;-- 处理login相关URL| || +- users.js &lt;-- 处理用户管理相关URL|+- app.js &lt;-- 使用koa的js|+- controller.js &lt;-- 自定义中间件|+- package.json &lt;-- 项目描述文件|+- node_modules/ &lt;-- npm安装的所有依赖包 app.js主文件12345678910111213141516const Koa = require('Koa');const bodyParser = require('koa-bodyparser');const controller = require('./controller');const app = new Koa();app.use(async(ctx, next) =&gt; &#123; console.log(`method: $&#123;ctx.method&#125;; url: $&#123;ctx.request.url&#125;`); await next();&#125;)//注册koa-bodyparser中间件app.use(bodyParser());//注册controller中间件app.use(controller());app.listen(8080);console.log('app started at port 8080...'); 在controllers目录下编写login.js：1234567891011121314151617181920212223242526let fn_index = async(ctx, name) =&gt; &#123; ctx.response.body = `&lt;h1&gt;Index&lt;/h1&gt; &lt;form action="/signin" method="post"&gt; &lt;p&gt;Name: &lt;input name="name" value="koa"&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;input name="password" type="password"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="Submit"&gt;&lt;/p&gt; &lt;/form&gt;`;&#125;;let fn_signin = async(ctx, next) =&gt; &#123; let name = ctx.request.body.name || '', password = ctx.request.body.password || ''; console.log(`name: $&#123;name&#125; ; password: $&#123;password&#125;`); if (name === 'koa' &amp;&amp; password === '12345') &#123; ctx.response.body = `&lt;h1&gt;Welcome, $&#123;name&#125;!&lt;/h1&gt;`; &#125; else &#123; ctx.response.body = `&lt;h1&gt;Login failed!&lt;/h1&gt; &lt;p&gt;&lt;a href="/"&gt;Try again&lt;/a&gt;&lt;/p&gt;`; &#125;&#125;;//module.exports把两个URL处理函数暴露出来module.exports = &#123; 'GET /': fn_index, 'POST /signin': fn_signin&#125;; 在controllers目录下编写users.js：1234567let fn_hello = async(ctx, next) =&gt; &#123; let name = ctx.params.name; ctx.response.body = `&lt;h1&gt;Hello,$&#123;name&#125;&lt;/h1&gt;`;&#125;;module.exports = &#123; 'GET /hello/:name': fn_hello&#125;; 在根目录下编写controller.js：123456789101112131415161718192021222324252627282930313233343536373839404142const fs = require('fs');function addMapping(router, mapping) &#123; for (let url in mapping) &#123; if (url.startsWith('GET ')) &#123; let path = url.substring(4); router.get(path, mapping[url]); console.log(`register URL mapping: GET $&#123;path&#125;`); &#125; else if (url.startsWith('POST ')) &#123; let path = url.substring(5); router.post(path, mapping[url]); console.log(`register URL mapping: POST $&#123;path&#125;`); &#125; else if (url.startsWith('PUT ')) &#123; let path = url.substring(4); router.put(path, mapping[url]); console.log(`register URL mapping: PUT $&#123;path&#125;`); &#125; else if (url.startsWith('DELETE ')) &#123; let path = url.substring(7); router.del(path, mapping[url]); console.log(`register URL mapping: DELETE $&#123;path&#125;`); &#125; else &#123; console.log(`invalid URL: $&#123;url&#125;`); &#125; &#125;&#125;function addControllers(router, dir) &#123; fs.readdirSync(__dirname + '/' + dir).filter((f) =&gt; &#123; return f.endsWith('.js'); &#125;).forEach((f) =&gt; &#123; console.log(`process controller: $&#123;f&#125;...`); let mapping = require(__dirname + '/' + dir + '/' + f); addMapping(router, mapping); &#125;);&#125;module.exports = (dir) =&gt; &#123; let controllers_dir = dir || 'controllers', router = require('koa-router')(); addControllers(router, controllers_dir); return router.routes();&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node框架Koa入门]]></title>
      <url>%2F2017%2F05%2F28%2FNode%E6%A1%86%E6%9E%B6Koa%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[安装koa：npm install koa 创建koa2工程文件app.js：//在Koa2中，Koa一个class，因此用大写的Koa表示: const Koa = require('Koa'); //创建Koa对象,表示web app本身 const app = new Koa(); // 对于任何请求,app都将调用该异步函数处理请求: app.use(async (ctx,next)=&gt;{ await next(); // 设置response的Content-Type: ctx.response.type = 'text/html'; // 设置response的内容: ctx.response.body = '&lt;h1&gt;Hello,koa2!&lt;/h1&gt;'; }) // 在端口8080监听: app.listen(8080); console.log('app started at port 8080...'); use参数: ctx :是封装了request和response的变量，可以通过它访问request和 response next :是koa传入的将要处理的下一个异步函数 上面的异步函数中，首先用await next();处理下一个异步函数,然后，设置response的Content-Type和内容由async标记的函数称为异步函数,在异步函数中,可以用await调用另一个异步函数 注意:ctx对象有一些简写的方法,例如ctx.url相当于ctx.request.url,ctx.type相当于ctx.response.type]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node基本模块：http]]></title>
      <url>%2F2017%2F05%2F28%2FNode%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97%EF%BC%9Ahttp%2F</url>
      <content type="text"><![CDATA[Node基本模块：http 导入http模块:1let http = require('http'); 创建HTTP服务器： http.createServer() request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息 response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器 12345678910111213141516171819let http = require('http');// 创建http server，并传入回调函数:let server = http.createServer((request, response) =&gt; &#123; // 回调函数接收request和response对象, // 获得HTTP请求的method和url: console.log(`$&#123;request.method&#125; : $&#123;request.url&#125;`); // 将HTTP响应200写入response, 同时设置Content-Type: text/html: response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); // 将HTTP响应的HTML内容写入response: response.end('&lt;h1&gt;Hello world!&lt;/h1&gt;');&#125;);// 让服务器监听8080端口:server.listen(8080);console.log('Server is running at http://127.0.0.1:8080/'); 创建文件服务器:依赖模块:1234const fs = require('fs'), http = require('http'), url = require('url'), path = require('path'); 解析URl需要url模块,通过url.parse()解析为url对象:123var url = require('url');console.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash')); 结果如下:12345678910111213Url &#123; protocol: 'http:', slashes: true, auth: 'user:pass', host: 'host.com:8080', port: '8080', hostname: 'host.com', hash: '#hash', search: '?query=string', query: 'query=string', pathname: '/path/to/file', path: '/path/to/file?query=string', href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' &#125; 处理本地文件目录需要path模块,它可以方便地构造目录:123456789let path = require('path');// 解析当前目录:let rootDir = path.resolve('.');console.log(rootDir); // f:\Node// 组合完整的文件路径:当前目录+'pub'+'index.html':let filePath = path.join(rootDir, 'pub', 'index.html');console.log(filePath); // f:\Node\pub\index.html' 完整代码:123456789101112131415161718192021222324252627282930313233343536const fs = require('fs'), http = require('http'), url = require('url'), path = require('path');//获取root目录:let root = path.resolve('.');console.log('Static root dir: ' + root);//创建服务器:let server = http.createServer((request, response) =&gt; &#123; // 获得URL的path let pathName = url.parse(request.url).pathname; // 获得对应的本地文件路径 let filePath = path.join(root, pathName); fs.stat(filePath, (err, stats) =&gt; &#123; if (!err &amp;&amp; stats.isFile()) &#123; // 没有出错并且文件存在 console.log(`200 $&#123;request.url&#125;`); // 发送200响应: response.writeHead(200); // 将文件流导向response: fs.createReadStream(filePath).pipe(response); &#125; else &#123; // 出错了或者文件不存在:response对象本身是一个Writable Stream console.log('404 ' + request.url); // 发送404响应: response.writeHead(404); response.end('404 Not Found'); &#125; &#125;)&#125;)server.listen(8080);console.log('Server is running at http://127.0.0.1:8080/'); 运行文件 浏览器输入http://127.0.0.1:8080/pub/index.html koa:12345678910111213const fs = require('fs');const Koa = require('Koa');const url = require('url');const app = new Koa();app.use(async(context, next) =&gt; &#123; console.log(`$&#123;context.method&#125;: $&#123;context.url&#125;`); let pathName = url.parse(context.request.url).pathname; let data = fs.readFileSync(__dirname + pathName, 'utf-8'); context.response.body = data; await next();&#125;)app.use(router.routes());]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node基本模块：stream]]></title>
      <url>%2F2017%2F05%2F28%2FNode%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97%EF%BC%9Astream%2F</url>
      <content type="text"><![CDATA[stream是Node.js提供的基本模块，目的是支持“流”这种数据结构。 流读取数据: fs.createReadStream() data事件表示流的数据已经可以读取了 end事件表示这个流已经到末尾了，没有数据可以读取 error事件表示出错了 样例：123456let fs = require('fs');//打开一个流let rs = fs.createReadStream('input.txt','utf-8');rs.on('data',datas=&gt;console.log(`DATA: $&#123;datas&#125;`));rs.on('end',()=&gt;console.log('END'));rs.on('error',err=&gt;console.log(`ERROR: $&#123;err&#125;`)); 流写入数据: fs.createWriteStream以流的形式写入文件，只需要不断调用write()方法，最后以end()结束12345let fs = require('fs');let ws = fs.createWriteStream('output.txt', 'utf-8');ws.write('使用Stream写入文本数据...\n');ws.write('END');ws.end(); pipe: readable.pipe(writable)所有的数据自动从Readable流进入Writable流，这种操作叫pipe,也就是复制文件1234let fs = require('fs');let rs = fs.createReadStream('input.png');let ws = fs.createWriteStream('output.png');rs.pipe(ws); 默认情况下，当Readable流的数据读取完毕,end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数：1readable.pipe(writable, &#123; end: false &#125;); 也可以这样?123456789let fs = require('fs');let rs = fs.createReadStream('input.png');let ws = fs.createWriteStream('output.png');rs.on('data', data =&gt; &#123; ws.write(data); ws.end();&#125;);rs.on('end', () =&gt; console.log('END'));rs.on('error', err =&gt; console(`ERROR: $&#123;err&#125;`));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node基本模块：fs]]></title>
      <url>%2F2017%2F05%2F27%2FNode%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97%EF%BC%9Afs%2F</url>
      <content type="text"><![CDATA[Node基本模块：fs 引入fs模块：1const fs = require("fs"); 读取文件: fs.readFile()1234567fs.readFile('input.txt', 'utf-8', (err, data) =&gt; &#123; if (err) &#123; return console.log(err); &#125;else&#123; console.log(data.toString()); &#125;&#125;) 写入文件: fs.writeFile()12345678let data = 'My name is zhiyu!'fs.writeFile('input.txt', data, err =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log('ok'); &#125;&#125;); stat isFile() 是否是文件 isDirectory() 是否是目录 size 文件大小 birthtime 创建时间 mtime 修改时间 123456789101112131415161718fs.stat('input.txt', (err, stat) =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; // 是否是文件: console.log(`isFile: $&#123;stat.isFile()&#125;`); // 是否是目录: console.log(`isDirectory: $&#123;stat.isDirectory()&#125;`); if (stat.isFile()) &#123; // 文件大小: console.log(`size: $&#123;stat.size&#125;`); // 创建时间, Date对象: console.log(`birth time: $&#123;stat.birthtime&#125;`); // 修改时间, Date对象: console.log(`modified time: $&#123;stat.mtime&#125;`); &#125; &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[typings的使用方法]]></title>
      <url>%2F2017%2F05%2F27%2Ftypings%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[通过typings完成代码提示 npm安装typings1npm install -g typings 查看版本1typings --version 搜索是否有需要的类型文件1typings search exampleName 安装相关提示信息文件12typings install dt~node --global --savetypings install lodash --save --global参数的使用场景 如果安装的包使用script标记来引用(如jQuery)(也就是在浏览器中使用) 这个包是属于环境的一部分(如node)时 该包没有使用--global安装失败时 启用智能提示功能方法一:1/// &lt;reference path="./typings/index.d.ts" /&gt; 方法二:在根目录建立jsconfig.json文件:基本格式如下:12345&#123; "files": [ "./typings/index.d.ts" ]&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node模块概念]]></title>
      <url>%2F2017%2F05%2F27%2FNode%E6%A8%A1%E5%9D%97%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[输出模块:1234function hello(name) &#123; console.log(`Hello,$&#123;name&#125;!`);&#125;module.exports = hello; 引入模块:12const hello = require('./hello');hello('Anson'); //Hello,Anson! 模块输出多个方法:12345678910111213//文件名为modulesfunction hello() &#123; console.log(`Hello,$&#123;name&#125;!`);&#125;function seyHei(name) &#123; console.log(`Hei,$&#123;name&#125;!`);&#125;module.exports = &#123; hello: hello, seyHei: seyHei,&#125;; 使用一个模块多个方法:123const modules = require('./modules');helloModule.hello('Anson');helloModule.seyHei('Anson');]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML之localStorage]]></title>
      <url>%2F2017%2F05%2F22%2FHTML%E4%B9%8BlocalStorage%2F</url>
      <content type="text"><![CDATA[直接给window.localStorage添加一个属性，例如：window.localStorage.name 赋值：1localStorage.name = 'Anson'; 2.取值:1localStorage.getItem('name'); //Anson 3.设置setItem:12localStorage.setItem('name','anson'); // 重新覆盖，变为了anson了localStorage.setItem('age','20'); 4.删除removeItem:12localStorage.removeItem('name');localStorage.getItem('name'); //null 5.全部清除clear:12localStorage.clear(); // 清除了所有localStorage.getItem('age'); //null]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[php获取Ajax数据]]></title>
      <url>%2F2017%2F05%2F22%2Fajax%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[最近一直苦于怎么用Ajax把数据提交到php,终于找到了解决变法.代码如下：12345let params = new URLSearchParams();params.append('username', 'Anson');axios.post('url', params) .then(response =&gt; msgP.innerHTML = username.value) .catch(error =&gt; console.log(error)); 1234&lt;?php$name = $_POST["username"];echo "$name";?&gt; 使用的axios库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[弹幕制作之没有性能]]></title>
      <url>%2F2017%2F05%2F06%2F%E5%BC%B9%E5%B9%95%E5%88%B6%E4%BD%9C-%E6%B2%A1%E6%9C%89%E6%80%A7%E8%83%BD%2F</url>
      <content type="text"><![CDATA[虽然不怎末好 , 但是也非常开心呢 ! Danmu类:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* * @ new Danmu(element) * element: 弹幕挂载点 * 方法: * @ add(data) 添加弹幕 * data: 文本数据 * @ remove() 移除弹幕 * * @ autoMove(source, dataName, method = "GET",) * ajax添加弹幕 * source: 数据来源 * dataName: 数据名称 */class Danmu &#123; constructor(el) &#123; this.el = el; this.timer = null; &#125; add(data) &#123; let element_p = document.createElement('p'), textNode = document.createTextNode(data), content = document.querySelector(this.el), element = this.el; element_p.appendChild(textNode); content.appendChild(element_p); content.style.position = 'relative' element_p.style.position = 'absolute'; element_p.style.right = '10px'; element_p.style.top = `$&#123;randomNunber()&#125;`; element_p.style.color = `$&#123;randomColor()&#125;`; leftMove(); //移动函数 function leftMove() &#123; let i = 10, timer = null, moveWidth = document .querySelector(element) .offsetWidth - element_p.offsetWidth - 10; timer = setInterval(function () &#123; element_p.style.right = `$&#123;i++&#125;px`; if (i == moveWidth) &#123; clearInterval(timer); element_p.style.display = 'none'; &#125; &#125;, 10) &#125; //随机位置 function randomNunber() &#123; let contentHeight = document .querySelector(element) .offsetHeight, randdom = `$&#123;Math.floor(Math.random() * (parseInt(contentHeight) - 50))&#125;px`; return randdom; &#125; //随机颜色 function randomColor() &#123; let r = Math.floor(Math.random() * 256), g = Math.floor(Math.random() * 256), b = Math.floor(Math.random() * 256), color = `rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`; return color; &#125; &#125; autoMove(source, dataName, method = "GET") &#123; //ajax const xhr = new XMLHttpRequest(), that = this; xhr.open(method, source + "?" + new Date().getTime(), true); xhr.send(null); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; let text = xhr.responseText, //获取数据 arr = JSON.parse(text), //转换为类数组 counter = 0; //计数器 //定时器 1秒执行一次 等于数据长度时清零 that.timer = setInterval(() =&gt; &#123; //自执行函数 (function () &#123; that.add(arr[counter][dataName]); counter += 1; if (counter == arr.length) &#123; counter = 0; &#125; &#125;)() &#125;, 1000) &#125; &#125; &#125; remove() &#123; let elements = document.querySelector(this.el), element_p = elements.querySelectorAll("p"), that = this; element_p.forEach(target =&gt; &#123; elements.removeChild(target); target.style.display = 'none'; &#125;) clearInterval(that.timer); &#125;&#125; 实例:DOM结构:123456&lt;div class="content"&gt;&lt;/div&gt;&lt;input type="text" placeholder="说点什么?"&gt;&lt;div class="btn"&gt; &lt;button type="submit" onclick=""&gt;提交&lt;/button&gt; &lt;button type="reset" onclick=""&gt;关闭&lt;/button&gt;&lt;/div&gt; CSS样式:1234567891011121314151617181920212223242526272829303132333435363738394041.content &#123; width: 75%; height: 400px; border: 2px solid blueviolet; margin: 10px auto; position: relative;&#125;input[type="text"] &#123; margin: 20px auto; display: block; width: 300px; height: 30px&#125;.btn &#123; width: 330px; margin: 10px auto;&#125;button[type="submit"] &#123; border: 1px solid rgb(230, 80, 30); border-radius: 3px; background-color: white; width: 159px; height: 35px; line-height: 35px; font-size: 14px; color: rgb(230, 80, 0);&#125;button[type="reset"] &#123; border: 1px solid rgb(176, 168, 165); border-radius: 3px; background-color: white; width: 159px; height: 35px; line-height: 35px; font-size: 14px; color: rgb(176, 168, 165);&#125; js部分:注意引入Danmu.js1234567891011121314151617181920212223242526272829let text = document.querySelector('input[type="text"]'), submit = document.querySelector('button[type="submit"]'), reset = document.querySelector('button[type="reset"]'), danmu = new Danmu('.content'), number = 0; submit.addEventListener('click', function () &#123; danmu.add(text.value); text.value = '';&#125;)reset.addEventListener('click', function () &#123; if (number == 0) &#123; danmu.remove() number += 1; reset.innerHTML = '开启'; &#125;else if(number == 1)&#123; danmu.autoMove("ajax.json", "text"); number = 0; reset.innerHTML = '关闭'; &#125;&#125;)text.addEventListener('keydown', function (event) &#123; if (event.keyCode === 13) &#123; danmu.add(text.value); text.value = ''; &#125;&#125;)danmu.autoMove("ajax.json", "text 效果: 下面的是第一版: old Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/* * @addDanmu(element,data) * element: 挂载对象 * data: 添加文本 * * @autoMove(element, source, dataName, method = "GET") * element: 挂载对象 * source: 数据来源 * dataName: 数据名称 * method: GET POST 默认GET * * @removeElement(element) * element: 挂载对象 等同上 */let text = document.querySelector('input[type="text"]'), submit = document.querySelector('button[type="submit"]'), reset = document.querySelector('button[type="reset"]');submit.addEventListener('click', function () &#123; console.log('文本输入值' + text.value); addDanmu('.content', text.value); text.value = '';&#125;)reset.addEventListener('click', function () &#123; removeElement('.content');&#125;)text.addEventListener('keydown', function (event) &#123; console.log('文本输入值' + text.value); console.log('键位码' + event.keyCode); if (event.keyCode === 13) &#123; addDanmu('.content', text.value); text.value = ''; &#125;&#125;)autoMove('.content', "ajax.json", "text");//获取数据 自动播放函数function autoMove(element, source, dataName, method = "GET", ) &#123; //ajax const xhr = new XMLHttpRequest(); xhr.open(method, source + "?" + new Date().getTime(), true); xhr.send(null); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; let text = xhr.responseText, //获取数据 arr = JSON.parse(text), //转换为类数组 counter = 0; //计数器 //定时器 1秒执行一次 等于数据长度时清零 setInterval(() =&gt; &#123; //自执行函数 (function () &#123; addDanmu(element, arr[counter][dataName]); counter += 1; if (counter == arr.length) &#123; counter = 0; &#125; console.log(counter); &#125;)() &#125;, 1000) //失败品 1 // for (let i = 0; i &lt; arr.length; i++) &#123; // setInterval(function () &#123; // (function () &#123; // console.log(i) // addDanmu(arr[i].text); // &#125;)(i) // &#125;, 2000) // &#125; //失败品 2 // arr.forEach(e =&gt; &#123; // console.log(e.text); // setInterval(() =&gt; &#123; // addDanmu(e.text); // &#125;, 5000) // &#125;) &#125; &#125;&#125;//添加弹幕动画函数function addDanmu(element, data) &#123; let element_p = document.createElement('p'), textNode = document.createTextNode(data), content = document.querySelector(element); element_p.appendChild(textNode); content.appendChild(element_p); content.style.position = 'relative' element_p.style.position = 'absolute'; element_p.style.right = '10px'; element_p.style.top = `$&#123;randomNunber()&#125;`; element_p.style.color = `$&#123;randomColor()&#125;`; console.log(element_p.offsetWidth) leftMove(); //移动函数 function leftMove() &#123; let i = 10, timer = null, moveWidth = document.querySelector(element).offsetWidth - element_p.offsetWidth - 10; timer = setInterval(function () &#123; element_p.style.right = `$&#123;i++&#125;px`; if (i == moveWidth) &#123; clearInterval(timer); element_p.style.display = 'none'; &#125; &#125;, 10) &#125; //随机位置 function randomNunber() &#123; let contentHeight = document.querySelector(element).offsetHeight, randdom = `$&#123;Math.floor(Math.random() * (parseInt(contentHeight)-50))&#125;px`; console.log('随机位置' + randdom); return randdom; &#125; //随机颜色 function randomColor() &#123; let r = Math.floor(Math.random() * 256), g = Math.floor(Math.random() * 256), b = Math.floor(Math.random() * 256), color = `rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`; console.log('随机颜色' + color); return color; &#125;&#125;//重置函数function removeElement(element) &#123; let elements = document.querySelector(element), element_p = elements.querySelectorAll("p"); console.log(element_p); element_p.forEach(target =&gt; &#123; elements.removeChild(target); target.style.display = 'none'; &#125;)&#125; 效果图:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阻止事件默认行为之图片查看]]></title>
      <url>%2F2017%2F05%2F06%2F%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%E4%B9%8B%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%2F</url>
      <content type="text"><![CDATA[addEventListener 和 onclick 不同的阻止方法addEventListener 是 DOM2级事件 ; onclick 是DOM0级事件 addEventListener 的阻止默认事件：(e.preventDefault()方法)1234element.addEventListener('click',function(e)&#123; ...调用方法 e.preventDefault()；&#125;,false) 栗子：(图片查看)12345678910111213141516171819function showpic(target) &#123; let source = target.getAttribute('href'); let img = document.querySelector('img'); console.log(img); img.setAttribute("src", source);&#125;function prepareGallery() &#123; const links = document.querySelectorAll("#showpic li a"); links.forEach(function (el) &#123; //不能使用箭头函数 el.addEventListener('click',function(e)&#123; showpic(this); e.preventDefault(); &#125;,false) &#125;)&#125;prepareGallery(); onclick 的阻止默认事件：(只需要 return false 即可)1234element.onclick = function()&#123; ...调用方法 return fasle;&#125; 栗子：(图片查看)123456789101112131415161718function showpic(target) &#123; let source = target.getAttribute('href'); let img = document.querySelector('img'); console.log(img); img.setAttribute("src", source); return true;&#125;function prepareGallery() &#123; const links = document.querySelectorAll("#showpic li a"); links.forEach(function (el) &#123; el.onclick = function () &#123; // 阻止跳转 return !showpic(this); &#125; &#125;);&#125;prepareGallery(); DOM结构：123456789&lt;div id="showpic"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="1.jpg"&gt;one pic&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="2.jpg"&gt;two pic&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;img alt="暂时没有图片"&gt; &lt;/div&gt;&lt;/div&gt; CSS样式：12345678910#showpic &#123; display: flex;&#125;#showpic img &#123; width: 300px; height: 200px; overflow: hidden; margin-left: 60px;&#125; 效果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[差了很多的开关按钮]]></title>
      <url>%2F2017%2F05%2F06%2F%E5%B7%AE%E4%BA%86%E5%BE%88%E5%A4%9A%E7%9A%84%E5%BC%80%E5%85%B3%E6%8C%89%E9%92%AE%2F</url>
      <content type="text"><![CDATA[没有什么用的…123456789101112131415161718192021222324252627282930313233343536373839class Button &#123; constructor(el = 'body', width = '60px', height = '20px') &#123; this.el = document.querySelector(el); this.width = width; this.height = height; this.el.innerHTML = ` &lt;div id="btn"&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt; ` let btn = document.querySelector('#btn'), state = document.querySelector('#btn&gt;div'); // 样式 btn.style.width = this.width; btn.style.height = this.height; btn.style.background = 'rgb(100, 100, 100)'; btn.style.borderRadius = this.height; btn.style.position = 'relative'; state.style.width = this.height; state.style.height = this.height; state.style.border = 'none'; state.style.borderRadius = '50%'; state.style.background = 'palevioletred'; state.style.position = 'absolute'; state.style.left = '0px'; console.log(this.height) // 点击事件 state.addEventListener("click", () =&gt; &#123; if (state.style.left == '0px') &#123; state.style.left = `$&#123;parseInt(this.width)-parseInt(this.height)&#125;px`; btn.style.background = 'pink'; &#125; else &#123; state.style.left = "0px"; btn.style.background = 'rgb(100, 100, 100)'; &#125; &#125;) &#125;&#125;let btn = new Button('#btn', '200px', '50px'); new Button(挂载点,宽,高)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax 常用方法]]></title>
      <url>%2F2017%2F05%2F05%2FAjax%2F</url>
      <content type="text"><![CDATA[Ajax是交互不可缺少的 1.创建XMLHttpRequest对象:1const xhr = new XMLHttpRequest()' IE5,IE6使用ActiveXObject(“Microsoft.XMLHTTP”)我觉得可以抛弃IE5,IE6… 2.向服务器发送请求:(使用 open()方法 和 send()方法)12xhr.open("GET","a.txt",true);xhr.send(); open(method,url,async) methid: 请求类型;GET或POST url: 文件地址 async: 是否开启异步send(string)将请求发送到服务器 string: 仅用于POST方法 GET与POST比较:大部分情况请使用GET;以下情况使用POST: 无法使用缓存文件(更新服务器上的数据或数据库) 向服务器发送大量数据(POST没有数据限制) 发送包含未知字符的用户输入,POST更稳当setRequestHeader(header,value)此方法仅用于POST方法向请求添加HTTP头 header: 头的名称 value: 头的值1234 //加上时间戳为了组织缓存 new Date().getTime()xhr.open("POST","a.txt"+ "?" + new Date().getTime(),true);xhr.setrequestHeader("Content-type","application/x-www-form-urlencoded");xhr.send(); 3.获得服务器响应:responseText:获得字符串形式的响应数据responseXML:获得XML形式的响应数据不是XML的使用responseText 4. onreadystatechange 事件:执行一些基于响应的任务每当 readyState 改变时，就会触发 onreadystatechange 事件下面是 XMLHttpRequest 对象的三个重要的属性：当 readyState 等于 4 且 status 状态为 200 时，表示响应已就绪：12345678xhr.onreadystatechange=function()&#123; if (xhr.readyState==4 &amp;&amp; xhr.status==200) &#123; //获得数据 let text = xhr.responseText; &#125;&#125; Ajax方法封装:比较简陋…1234567891011121314151617 ajaxi(&#123; url: "ajax_1.txt", success: function (res) &#123; console.log(res); &#125;, error: function () &#123; console.log("失败"); &#125;, data: &#123; name: 'anson', age : 17 &#125;, method: "post", //默认为GET cache: false, //默认false阻止缓存 开启缓存设为true async: true //默认为开启异步 &#125;)&#125;); 123456789101112131415161718192021222324252627282930313233343536373839function ajaxi(json) &#123; let method = json.method ? json.method.toUpperCase() : "GET", url = json.url, txt = /.txt$/,jsons = /.json$/, success = json.success, error = json.error, async = json.async ? json.async : true, cache = json.cache ? json.cache : false, cacheUrl = cache ? url : url + "?a=" + new Date().getTime(), data = json.data ? json.data : null, datas = '', ajaxi = new XMLHttpRequest(); if(data instanceof Object)&#123; for(key in data)&#123; if(data.hasOwnProperty(key))&#123; datas += key + ":" + data[key] + " ; " &#125; &#125; &#125; ajaxi.open(method, cacheUrl, async); ajaxi.setRequestHeader('content-type' , 'application/x-www-form-urlencoded'); ajaxi.send(datas); console.log(datas); ajaxi.onreadystatechange = function () &#123; if (ajaxi.readyState == 4) &#123; if (ajaxi.status == 200) &#123; if(txt.test(url))&#123; success(ajaxi.responseText) &#125;else if (jsons.test(url))&#123; success(eval(ajaxi.responseText)); &#125;else&#123; success(ajaxi.responseText); &#125; &#125; else &#123; error(ajaxi.status); &#125; &#125; &#125;&#125; 底下这是啥 不知道 不知道 不知道12345new Anson("url地址") .content(function (rse) &#123; console.log(rse[0].user) &#125;, function () &#123; console.log("错误"); 123456789101112131415161718192021class Anson &#123; constructor(url) &#123; this.url = url; this.ajaxi = new XMLHttpRequest(); &#125; content(text,error) &#123; let that = this; that.ajaxi.open("GET", this.url, true); that.ajaxi.send(); that.ajaxi.onreadystatechange = function () &#123; if (that.ajaxi.readyState == 4) &#123; if (that.ajaxi.status == 200) &#123; text(eval(that.ajaxi.responseText)); &#125; else &#123; error(that.ajaxi.status); &#125; &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用flex布局初试]]></title>
      <url>%2F2017%2F05%2F01%2F%E4%BD%BF%E7%94%A8flex%E5%B8%83%E5%B1%80%E5%88%9D%E8%AF%95%2F</url>
      <content type="text"><![CDATA[第一次使用flex布局 有点混乱…DOM结构:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id="wrapper"&gt; &lt;header&gt; &lt;section&gt; &lt;h1&gt;Anson&lt;/h1&gt; &lt;/section&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;Acticles&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;Books&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;Resources&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;bookshelf&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;Contact Me&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;form action="#" method="post"&gt; &lt;label for="urse_name"&gt;搜索&lt;/label&gt; &lt;input type="text" name="urse_name" id="urse_name" placeholder="搜索"&gt; &lt;/form&gt; &lt;/header&gt; &lt;main&gt; &lt;section&gt; &lt;active&gt; &lt;h4&gt;May 1,2017&lt;/h4&gt; &lt;a href="#"&gt; &lt;h3&gt;this is...&lt;/h3&gt; &lt;/a&gt; &lt;img src="mo.jpg" alt="" width="300px"&gt; &lt;p&gt;This is ...This is ...This is ...This is ...This is ...This is ...This is ...This is ...This is ...This is ...&lt;/p&gt; &lt;/active&gt; &lt;/section&gt; &lt;aside&gt; &lt;form action="#" method="post"&gt; &lt;h3&gt;Sign In Code Updates&lt;/h3&gt; &lt;label for="mail"&gt;Email&lt;/label&gt; &lt;input type="text" name="mail" id="mail" placeholder="Emali"&gt; &lt;label for="pass"&gt;password&lt;/label&gt; &lt;input type="password" name="psass" id="pass" placeholder="password"&gt; &lt;button type="submit" value="join in"&gt;Join In&lt;/button&gt; &lt;p&gt;Not signed up?&lt;a href="#"&gt;Register now.&lt;/a&gt;&lt;/p&gt; &lt;/form&gt; &lt;/aside&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;Anson's exclusive page&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; CSS样式为:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182* &#123; margin: 0; padding: 0; text-decoration: none; list-style: none; outline: none;&#125;body &#123; background: #efefef;&#125;#wrapper &#123; display: flex; flex-direction: column; margin: 10px 60px;&#125;header &#123; flex: 1; display: flex; padding: 20px; height: 70px; line-height: 70px; background: #fff; border-radius: 20px 0 20px 0; box-shadow: 0px 2px 2px 0px black;&#125;header section &#123; flex: 0.5; letter-spacing: 0.25em; color: #4eb8ea;&#125;header nav &#123; flex: 1;&#125;header form &#123; flex: 0.5;&#125;header nav li &#123; float: left;&#125;header nav li a &#123; padding: 5px 9px;&#125;header form input &#123; width: 75px; border-radius: 10px 0 10px 0; padding: 2px 0 3px 5px; font-weight: 400; color: pink; transition: 1s width; float: right; position: relative; top: 23px;&#125;header input:focus &#123; width: 140px;&#125;header input::-webkit-input-placeholder &#123; color: paleturquoise;&#125;header form label &#123; display: none;&#125;header nav li a &#123; font-weight: 600; color: paleturquoise;&#125;header nav li:nth-child(1) a &#123; background: #f58c21; border-radius: 10px 0 0 5px;&#125;header nav li:nth-child(2) a &#123; background: #4eb8ea;&#125;header nav li:nth-child(3) a &#123; background: #d6e636;&#125;header nav li:nth-child(4) a &#123; background: #ee4c98;&#125;header nav li:nth-child(5) a &#123; background: #f58c21; border-radius: 0 5px 10px 0;&#125;header nav li:hover a &#123; color: #555;&#125;main &#123; flex: 1; display: flex; margin-top: 20px;&#125;main section &#123; flex: 1; margin-right: 20px; padding: 10px; border-radius: 20px 0 20px 0; background: #fff; box-shadow: 0px 2px 2px 0px black;&#125;main img &#123; float: left&#125;main active p &#123; float: left; padding-left: 20px; width: 300px; word-wrap: break-word;&#125;main active p::first-letter &#123; font-size: 4.5em; line-height: 0.7;&#125;main aside &#123; /*flex: 0.5;*/ width: 300px; position: relative; right: 0; padding: 10px; border-radius: 20px 0 20px 0; background: #fff; box-shadow: 0px 2px 2px 0px black;&#125;main form &#123; margin-left: 30px;&#125;main aside input &#123; display: block; padding: 3px; margin: 3px;&#125;main aside button &#123; display: block; width: 100px; height: 30px; background: orange; border: none; border-radius: 10px 0 10px 0; margin: 10px 0 0 80px;&#125;main aside p &#123; margin-top: 20px; font-size: .6em&#125;footer&#123; flex: 1; background: #fff; margin-top: 30px; height: 50px; text-align: center; line-height: 50px; font-weight: 600; border-radius: 10px 0 10px 0; 效果为:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[弹出层]]></title>
      <url>%2F2017%2F05%2F01%2F%E5%BC%B9%E5%87%BA%E5%B1%82%2F</url>
      <content type="text"><![CDATA[弹出层DOM结构:123456789101112131415&lt;figure&gt; &lt;img src="mo.jpg"&gt; &lt;figcaption&gt; &lt;h3&gt;萌萌&lt;/h3&gt; &lt;a href="#"&gt;info&lt;/a&gt; &lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt; &lt;img src="mo.jpg"&gt; &lt;figcaption&gt; &lt;h3&gt;萌萌&lt;/h3&gt; &lt;a href="#"&gt;info&lt;/a&gt; &lt;/figcaption&gt;&lt;/figure&gt; CSS样式:12345678910111213141516171819202122232425262728293031323334353637383940figure &#123; width: 200px; height: 150px; margin: 20px; border: 1px #666 solid; position: relative; float: left;&#125;img &#123; /*display是为了去除图片下方基线空白*/ display: block; width: 200px; height: 150px;&#125;figcaption&#123; display: none; position: absolute; left: 50%;top: 20px; width: 130px; padding: 10px; background: #f2eaea; border: 3px palevioletred solid; border-radius: 6px;&#125;figcaption h3&#123; font-size: 14px; color: #666; margin-bottom: 6px;&#125;figcaption a&#123; display: block; text-decoration: none; font-size: 12px; color: #000;&#125;figure:hover figcaption&#123; display: block; z-index: 2;&#125; 效果: CSS制造三角形:1&lt;div&gt;&lt;/div&gt; 123456div&#123; border: 12px solid; border-color: transparent palegreen transparent transparent; width: 0px; height: 0px;&#125; 用before添加三角 给弹出层12345678910figcaption::before&#123; content: ""; width: 0px; height: 0px; border: 12px solid; border-color: transparent palevioletred transparent transparent; position: absolute; right: 100%; top: 20px;&#125; 效果:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搜索菜单]]></title>
      <url>%2F2017%2F05%2F01%2F%E6%90%9C%E7%B4%A2%E8%8F%9C%E5%8D%95%2F</url>
      <content type="text"><![CDATA[搜索菜单DOM结构:123456&lt;header&gt; &lt;form action="#" method="post"&gt; &lt;label for="search"&gt;search&lt;/label&gt; &lt;input type="search" name="search" id="search" placeholder="点击搜索"&gt; &lt;/form&gt;&lt;/header&gt; CSS样式:1234567891011121314151617181920212223242526272829*&#123; margin: 0; padding: 0;&#125;header&#123; overflow: hidden; width: 500px; border-radius: 3px; background: #ddd;&#125;form&#123; float: right; padding: 5px;&#125;form input&#123; width: 75px; padding: 3px; /*取消默认突出边框*/ outline: none; border-color: #eee #ccc #ccc #eee; border-radius: 10px; transition: 1s width;&#125;form input:focus&#123; width: 200px;&#125;form label&#123; display: none;&#125; 效果:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[下拉菜单]]></title>
      <url>%2F2017%2F04%2F30%2F%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%2F</url>
      <content type="text"><![CDATA[下拉菜单DOM为:1234567891011121314151617181920&lt;nav class="list"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;two&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;three&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;two&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;two&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;three&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;three&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;four&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; CSS样式:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*一定要去除默任样式害人啊 !!!*/*&#123; margin: 0; padding: 0;&#125;.list ul li&#123; float: left; list-style: none; position: relative;&#125;.list li li &#123; float: none; &#125;/*把样式都设置在a链接上*/.list a&#123; display: block; width: 60px; height: 40px; background: palegreen; color: white; text-align: center; text-decoration: none; line-height: 40px; /*如果有三级菜单不能取消二级菜单右边框 取消会有bug*/ border-right: 3px white solid; &#125;/*取消一级菜单最后一个a边框*//*.list &gt; ul &gt; li:last-child a&#123; border-right: none;&#125;*//*定位二级菜单并隐藏*/.list li ul&#123; display: none; position: absolute; top: 100%; left: 0; &#125;/*为二级菜单设置边框*/.list ul li ul li&#123; border-top: 3px white solid;&#125;/*一级菜单hover二级显示*/.list li:hover ul&#123; display: block;&#125;/*设置所有hover样式*/.list li:hover &gt; a&#123; color: palegoldenrod; background: paleturquoise; border-top: 1px solid;&#125;/*隐藏三级菜单*/.list li:hover ul li ul&#123; display: none;&#125;/*定位显示三级菜单*/.list li ul li:hover ul&#123; display: block; position: absolute; top: -1px; left: 100%;&#125; 效果图: 下面的 稀里糊涂 上面的也稀里糊涂 可能比下面的好?DOM结构为:12345678910111213141516171819202122232425262728&lt;nav class="list"&gt; &lt;!--一级开始--&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;一级菜单-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;一级菜单-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;一级菜单-3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;一级菜单-4&lt;/a&gt; &lt;!--二级开始--&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;二级菜单-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;二级菜单-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;二级菜单-3&lt;/a&gt; &lt;!--三级开始--&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;三级菜单-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;三级菜单-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;三级菜单-3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;三级菜单-4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!--三级结束--&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;二级菜单-4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!--二级结束--&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!--一级结束--&gt;&lt;/nav&gt; CSS样式为:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748.list li&#123; float: left; list-style: none; /* 为子菜单提供定位*/ position: relative;&#125;.list li a&#123; display: block; padding: 3px 10px; background: palegreen; text-decoration: none; border-right: 3px white solid; color: white; &#125;.list li:last-child a&#123; border-right: none;&#125;.list a:hover&#123; color: pink;&#125;.list li ul&#123; display: none; width: 6.3em; /*相对父级定位*/ position: absolute; top: 100%; left: -40%;&#125;.list li li a&#123; /*去掉继承边框*/ border-right-style: none; border-top: solid;&#125;.list li li&#123; float: none;&#125;.list li:hover ul&#123; display: block;&#125;.list li:hover ul&gt;li ul&#123; display: none;&#125;.list li ul li:hover ul&#123; display: block; position: absolute; top: 0; left: 64%;&#125; 效果为:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[纵向菜单]]></title>
      <url>%2F2017%2F04%2F30%2F%E7%BA%B5%E5%90%91%E8%8F%9C%E5%8D%95%2F</url>
      <content type="text"><![CDATA[纵向菜单DOM结构为:12345678&lt;nav class="list"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;two&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;three&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;four&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; CSS样式为:1234567891011121314151617181920212223242526272829303132333435 *&#123; margin: 0; padding: 0; list-style: none;&#125;nav&#123; margin: 50px; width: 150px;&#125;.list ul&#123; border: 1px solid #f00; border-radius: 3px;&#125;/* li + li:非首位选择 等同于: li&#123;border-top: 1px solid #f00;&#125; li:first-child&#123;border-top: none;&#125;*/.list li + li &#123; border-top: 1px solid #f00;&#125;.list li a&#123; display: block; padding: 3px 10px; text-decoration: none; text-align: center; font: 20px; font-weight: 400; color: #000; background: #ffed53;&#125;.list li a:hover&#123; color: #069;&#125; 效果图为:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[横向菜单]]></title>
      <url>%2F2017%2F04%2F30%2F%E6%A8%AA%E5%90%91%E8%8F%9C%E5%8D%95%2F</url>
      <content type="text"><![CDATA[最基本的DOM结构为:12345678&lt;nav class="list"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;two&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;three&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;four&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; CSS样式:12345678910111213141516171819.list ul&#123; overflow: hidden;&#125;.list li&#123; float: left; list-style: none;&#125;.list li a&#123; display: block; padding: 0 16px; text-decoration: none; color: #999;&#125;.list li + li&#123; border-left: 1px solid #aaa;&#125;.list li a:hover&#123; color: #555;&#125; 效果为:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flex基本语法]]></title>
      <url>%2F2017%2F04%2F29%2Fflex%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 1. 指定Flex布局块级元素:123#content&#123; display: flex;&#125; 行内元素:123#content&#123; display: flex;&#125; 2. 基本属性 flex-direction 属性决定主轴的方向（即项目的排列方向） flex-direction：row(左对齐) | row-reverse(右对齐) | column(顶对齐) | column-reverse(底对齐) 1234.box &#123; display:flex; flex-direction: row | row-reverse | column | column-reverse;&#125; flex-wrap 如果一条轴线排不下，如何换行 flex-wrap: nowrap(不换行) | wrap(换行，第一行在上方) | wrap-reverse(换行，第一行在下方) 123456.boxs&#123; display: flex;&#125;.box1&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; flex-flow 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap不写了…菜鸟教程 Flex阮一峰 Flex语法基础阮一峰 Flex布局实例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS中栏流动布局(flex)]]></title>
      <url>%2F2017%2F04%2F29%2FCSS%E4%B8%AD%E6%A0%8F%E6%B5%81%E5%8A%A8%E5%B8%83%E5%B1%80-flex%2F</url>
      <content type="text"><![CDATA[这回用flex实现左右固定 , 中间流动的布局格式.实现 圣杯布局 …. 最基本的` DOM结构为： ·12345&lt;div class="container"&gt; &lt;div id="left"&gt;left&lt;/div&gt; &lt;div id="main"&gt;main&lt;/div&gt; &lt;div id="right"&gt;right&lt;/div&gt;&lt;/div&gt; CSS样式为:123456789101112131415161718.container&#123; display: flex;&#125;#main&#123; flex: 1; height: 300px; background: palevioletred&#125;#left&#123; flex: 0 0 300px; height: 300px; background: palegreen;&#125;#right&#123; flex: 0 0 300px; height: 300px; background: palegoldenrod;&#125; 实现效果为: 实现圣杯布局DOM结构为:123456789&lt;div class="HolyGrail"&gt; &lt;header class="HolyGrail_header"&gt;header&lt;/header&gt; &lt;div class="HolyGrail_body"&gt; &lt;main class="HolyGrail_baoy_main"&gt;main&lt;/main&gt; &lt;nav class="HolyGrail_baoy_nav"&gt;nav&lt;/nav&gt; &lt;aside class="HolyGrail_baoy_aside"&gt;aside&lt;/aside&gt; &lt;/div&gt; &lt;footer class="HolyGrail_footer"&gt;footer&lt;/footer&gt;&lt;/div&gt; CSS样式为:1234567891011121314151617181920212223242526272829303132333435363738394041424344.HolyGrail &#123; display: flex; min-height: 100vh; flex-direction: column;&#125;.HolyGrail_header,.HolyGrail_body,.HolyGrail_footer &#123; flex: 1;&#125;.HolyGrail_body&#123; display: flex;&#125;.HolyGrail_baoy_main&#123; background: palegoldenrod; flex: 1;&#125;.HolyGrail_baoy_nav&#123; flex: 0 0 12em; order: -1; background: pink;&#125;.HolyGrail_baoy_aside&#123; flex: 0 0 12em; background: palegreen;&#125;.HolyGrail_header&#123; background: palevioletred;&#125;.HolyGrail_footer&#123; background: powderblue;&#125; @media (max-width:760px)&#123; .HolyGrail_body&#123; display: flex; flex-direction: column; &#125; .HolyGrail_baoy_main, .HolyGrail_baoy_nav, .HolyGrail_baoy_aside&#123; flex: auto; &#125;&#125; 实现效果为:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS中栏流动布局(table)]]></title>
      <url>%2F2017%2F04%2F29%2FCSS%E4%B8%AD%E6%A0%8F%E6%B5%81%E5%8A%A8%E5%B8%83%E5%B1%80-tabletable%2F</url>
      <content type="text"><![CDATA[把要实现的display属性都设为 table-cell , 两侧固定宽度 , 中间的内容就会随着内容而撑开.DOM结构为:123456789&lt;nav&gt;left&lt;/nav&gt;&lt;active&gt; main &lt;p id="none"&gt; &lt;!--占位用的...--&gt; mainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmainmian &lt;/p&gt;&lt;/active&gt;&lt;aside&gt;right&lt;/aside&gt; CSS样式为:12345678910111213141516171819202122nav&#123; display: table-cell; width: 300px; height: 500px; background: palegreen;&#125;active&#123; display: table-cell; height: 500px; word-break: break-all; background: palevioletred;&#125;aside&#123; display: table-cell; width: 300px; height: 500px; background: palegoldenrod;&#125;/* 占位的... */#none&#123; visibility: hidden;&#125; 实现效果为:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS中栏流动布局(圣杯?)]]></title>
      <url>%2F2017%2F04%2F29%2FCSS%E4%B8%AD%E6%A0%8F%E6%B5%81%E5%8A%A8%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[大概可能是圣杯布局吧 ? 不管了 , 反正是三栏中栏流动式布局 , 中间也没有被遮盖 !DOM 结构为:12345&lt;div id="main"&gt; &lt;div id="left"&gt;left&lt;/div&gt; &lt;div id="center"&gt;center&lt;/div&gt; &lt;div id="right"&gt;right&lt;/div&gt;&lt;/div&gt; CSS样式为:1234567891011121314151617181920212223242526272829303132333435363738394041* &#123; margin: 0; padding: 0;&#125;#main &#123; position: relative; /* 给左右两固定栏流出位置 解决遮盖中间流动层的被遮盖问题 */ padding-left: 300px; padding-right: 300px; /* 如果想要固定main宽度 则需抛出左右两侧的宽度 width:360px; 实际宽度则是:(360+300+300)px */&#125;#center &#123; width: 100%; height: 500px; background: greenyellow;&#125;#left &#123; width: 300px; height: 500px; background: paleturquoise; position: absolute; top: 0; left: 0;&#125;#right &#123; width: 300px; height: 500px; background: pink; position: absolute; top: 0; right: 0;&#125; 实现效果为:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单例模式(Singleton)]]></title>
      <url>%2F2017%2F04%2F25%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[Singleton模式是最常见的模式之一,它提供了一个命名空间它限制了类的实例化次数只能是一次.从经典的意义上来说,Singleton 模式,在该实例不存在的情况下,可以通过一个方法创建一个类来实现创建类的新实例;如果实例已经存在,那么就会简单的返回该对象的引用.它不同于静态类（或对象）,因为我们可以推迟它们的初始化,这通常是因为它们需要一些信息,而这些信息在初始化期间可能无法获得. 最简单的单例模式:12345678910const Anson = &#123; getName() &#123; return "anson"; &#125;, sayHello() &#123; //通过this使用当前对象getName方法 return `$&#123;this.getName()&#125; say hello!`; &#125;,&#125; //通过Anson.getName访问 特权方法:1234567891011121314151617const Anson = (function () &#123; //私有变量 const info = &#123; AGE: 20, NAME: "Anosn", &#125; //特权方法 return &#123; get(method) &#123; return info[method] ? info[method] :null; &#125; &#125;&#125;)();//取值:Anson.get("NAME");Anson.get("AGE"); 惰性单例:123456789101112131415161718192021222324252627//惰性载入单例const lazySingleton = (function () &#123; //单例实例引用 let _instance = null; //单例 function init() &#123; //定义私有属性和方法 const privateName = "Anson"; return &#123; publicMethod() &#123; return privateName; &#125; &#125; &#125; return function () &#123; if (!_instance) &#123; _instance = init(); &#125; return _instance; &#125;&#125;)();const singleA = lazySingleton();const singleB = lazySingleton();singleA == singleB; //truesingleA.publicMethod();//"Anson"singleB.publicMethod();//"Anson" 我们看到上面的结果返回使 true,这说明,singleA 与 singleB 是同一个值,也就是 singleA 的值. 原因就在于该实例已经被检测到创建过了,因此,不会再次创建.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON的常用方法]]></title>
      <url>%2F2017%2F04%2F15%2FJSON%2F</url>
      <content type="text"><![CDATA[JSON是一种数据交换格式 序列化把对象转换为JSON格式:123456const MyObj = &#123; name: 'anson', age: 20&#125;JSON.stringify(MyObj);//"&#123;"name":"anson","age":20&#125;" 格式换行:1234567891011const MyObj = &#123; name: 'anson', age: 20&#125;JSON.stringify(MyObj,null,' ');/* "&#123; "name":"anson", "age":20 &#125;"*/ 第二个参数:筛选对象键值123456JSON.stringify(MyObj,["name"],' ');/* &#123; "name":"anson" &#125;*/ 传入函数对每个键值进行处理12345678910111213function convert(key,value) &#123; if(typeof value == 'string') &#123; return value.toUpperCase(); &#125; return value;&#125;JSON.stringify(MyObj,convert,' ');/* &#123; "name": "ANSON", "age": 20 &#125;*/ 精确控制序列化:似乎方法名称必须是toJSON1234567891011const MyObj = &#123; name: 'anson', age: 20, toJSON() &#123; return &#123; name: this.name &#125;; &#125; &#125;JSON.stringify(MyObj);//&#123;"name":"anson"&#125; 反序列化:把JSON转换为对象1234567const MyObj = &#123; name: 'anson', age: 20 &#125;const MyJson = JSON.stringify(MyObj);JSON.parse(MyJson)//Object &#123;name: "anson", age: 2&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[几种实现自增方法]]></title>
      <url>%2F2017%2F04%2F15%2F%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%A2%9E%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[用Generator 闭包 构造器实现自增 Generator:123456function* next_id() &#123; let index = 0; while (true) &#123; yield index++; &#125; &#125; 闭包:12345function next_id() &#123; let index = 0; return () =&gt; index++;&#125;let next = next_id(); 构造器:123456function Next_id() &#123; let indx = 0; this.next = function () &#123; return indx++; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript冒泡排序]]></title>
      <url>%2F2017%2F04%2F06%2FJavaScript%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[1234567891011121314function BubbleSort(arr) &#123; for (let i = 0; i &lt; arr.length - 1; i++) &#123; for (let j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; let temp = arr[j + 1]; arr[j + 1] = arr[j] arr[j] = temp; &#125; &#125; &#125; return arr;&#125;let arrs = [1, 8, 6, 3, 4, 9, 7];console.log(BubbleSort(arrs));//[1, 3, 4, 6, 7, 8, 9]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript之继承]]></title>
      <url>%2F2017%2F04%2F02%2FJavaScript%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[继承我是理解不透了,照葫芦画瓢吧!我觉得ES6的最简单最好用,一点不要费脑子 =-= ES6继承：123456789101112131415161718192021222324class Person &#123; constructor(name) &#123; this.name = name; &#125; getName() &#123; return this.name; &#125;&#125;class Baby extends Person &#123; constructor(name, age) &#123; super(name); //super 调用父类的constructor(name) this.age = age; &#125; getAge() &#123; return this.age; &#125;&#125;const baby = new Baby("baby", "1");console.log(baby.constructor == Person); //falseconsole.log(baby.constructor == Baby); //trueconsole.log(baby.__proto__); //Objectconsole.log(baby.getName()); //babyconsole.log(baby.getAge()); //1 借用构造函数:123456789101112function SuperType(name) &#123; this.name = name;&#125;function SubType(name, age) &#123; SuperType.apply(this, [name]); this.age = age;&#125;const subType = new SubType("anson", 20);console.log(subType.name);//ansonconsole.log(subType.age); //20 基于原型链的继承的写法：12345678910111213141516171819202122function Person(name, age) &#123; this.name = name; this.age = age;&#125; Person.prototype.getName = function () &#123; return this.name;&#125;*******Baby继承于Person*********function Baby(name, age) &#123; Person.apply(this, [name, age]); // Person.call(this,name,age;)&#125;// Baby.prototype = new Person();// Baby.prototype.constructor = Baby;Baby.prototype=Object.create(Person.prototype)const baby = new Baby("baby", "1");console.log(baby.getName()); //baby 注意：需要注意的是，如果在子类的prototype对象上也有getName方法，就会覆盖父类的，因为查找时在自己上面就找到了，就不会向上回溯了 问题： 1.没有实现传统oo该有的super方法来调用父类方法 2.直接将父类实例作为子类的原型，简单粗暴造成多余的原型属性 12Baby.prototype=Object.create(Person.prototype) console.log(baby._proto_); //undefined 3.construct的问题 12console.log(baby.constructor == Person) //trueconsole.log(baby.constructor == Baby) //false 对基于原型链的继承的写法进行改良：1234567891011121314151617181920212223function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function () &#123; return this.name;&#125;function Baby(name, age) &#123; Person.apply(this, [name, age]); // Person.call(this,name,age;)&#125;let Func = function () &#123;&#125;;Func.prototype = Person.prototype;Baby.prototype = new Func();Baby.prototype.constructor = Baby;const baby = new Baby("baby", "1");console.log(baby.constructor == Person); //falseconsole.log(baby.constructor == Baby); //trueconsole.log(baby.__proto__); //Objectconsole.log(baby.getName()); //baby 将其进行封装：1234let Func = function () &#123;&#125;;Func.prototype = Person.prototype;Baby.prototype = new Func();Baby.prototype.constructor = Baby; 封装为：12345678910function objectCreate(prototype) &#123; let Func = function () &#123;&#125;; Func.prototype = prototype; return new Func();&#125;function inherit(subclass, parentclass) &#123; subclass.prototype = objectCreate(parentclass.prototype); subclass.prototype.constructor = subclass;&#125; 于是继承可以写成：12345678910111213141516171819202122232425262728293031function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function () &#123; return this.name;&#125;function objectCreate(prototype) &#123; let Func = function () &#123;&#125;; Func.prototype = prototype; return new Func();&#125;function inherit(subclass, parentclass) &#123; subclass.prototype = objectCreate(parentclass.prototype); subclass.prototype.constructor = subclass;&#125;function Baby(name, age) &#123; Person.apply(this, [name, age]); // Person.call(this,name,age;)&#125;inherit(Baby,Person);const baby = new Baby("baby", "1");console.log(baby.constructor == Person); //falseconsole.log(baby.constructor == Baby); //trueconsole.log(baby.__proto__); //Objectconsole.log(baby.getName()); //baby]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构造函数的私有成员]]></title>
      <url>%2F2017%2F04%2F02%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%2F</url>
      <content type="text"><![CDATA[模块模式在定义单个对象的私有属性十分有效在构造函数中使用类似的模式来创建每个实例的私有数据1234567891011121314151617181920function Person(name) &#123; let age = 21; this.name = name; this.getAge = function () &#123; return age; &#125; this.growOlder = function () &#123; age++; &#125; &#125; let person = new Person("Anson"); console.log(person.name); //Anson console.log(person.getAge()); //21 person.age = 100; console.log(person.getAge()); //21 person.growOlder(); console.log(person.getAge()); //22 let person2=new Person("amn"); console.log(person2.name); //amn console.log(person2.getAge()); //21 所有实例可以共享的私有数据123456789101112131415161718192021222324let Person = (function () &#123; let age = 21; function InnerPerson(name) &#123; this.name = name; &#125; InnerPerson.prototype.getAge = function () &#123; return age; &#125; InnerPerson.prototype.growOlder = function () &#123; age++; &#125; return InnerPerson;&#125;())let person = new Person("Anson");console.log(person.name); //Ansonconsole.log(person.getAge()); //21person.age = 100;console.log(person.getAge()); //21person.growOlder();console.log(person.getAge()); //22let person2=new Person("amn");console.log(person2.name); //amnconsole.log(person2.getAge()); //22]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript闭包初识]]></title>
      <url>%2F2017%2F04%2F02%2FJavaScript%E9%97%AD%E5%8C%85%E5%88%9D%E5%AD%A6%2F</url>
      <content type="text"><![CDATA[稀碎啊稀碎! 模块的一般形式是：一个定义了“私有变量”和函数的函数，利用闭包的特性(即创建了可以访问“私有变量和函数”的特权函数)，最后将这些特权函数返回或保存到一个可以访问的地方。IIFE立即调用123456789101112131415161718let person = (function () &#123; let age = 21; return &#123; name: "Anson", getAge: function () &#123; return age; &#125;, growOlder: function () &#123; age++; &#125; &#125;; &#125;()); console.log(person.name); //Anson console.log(person.getAge()); //21 person.age = 100; console.log(person.getAge()); //21 person.growOlder(); console.log(person.getAge()); //22 使用模块模式创建person对象,变量age是给对象的私有属性,它无法被外界直接访问,但可以通过对象方法来访问，该对象有两个特权方法getAge()和goewOlder()模块模式的变种暴露模式：12345678910111213141516let person = (function () &#123; let age = 21; function getAge() &#123; return age; &#125; function gorwOlder() &#123; age++; &#125; return &#123; name: "Anson", getAge: getAge, gorwOlder: gorwOlder &#125;; &#125;()); 它将所有变量和方法都组织在IIFE的顶部，然后将它们设置到需要被返回的对象上它可以保障所有的变量和函数声明都在一处 理解下面的结果：12345678910var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); 1234567891011var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()());]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[layer]]></title>
      <url>%2F2017%2F03%2F15%2Flayer%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[css3制作导航条]]></title>
      <url>%2F2017%2F03%2F09%2Fcss3%E5%88%B6%E4%BD%9C%E5%AF%BC%E8%88%AA%E6%9D%A1%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;CSS制作立体导航&lt;/title&gt; &lt;style&gt; body &#123; background: #ebebeb; &#125; .nav &#123; width: 560px; height: 50px; font: bold 0/50px Arial; text-align: center; margin: 40px auto 0; background: #f65f57; /*制作圆*/ border-radius: 10px; /*制作导航立体风格*/ box-shadow: 1px 5px rgb(108, 74, 64) &#125; .nav a &#123; display: inline-block; -webkit-transition: all 0.2s ease-in; -moz-transition: all 0.2s ease-in; -o-transition: all 0.2s ease-in; -ms-transition: all 0.2s ease-in; transition: all 0.2s ease-in; &#125; .nav a:hover &#123; -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -o-transform: rotate(10deg); -ms-transform: rotate(10deg); transform: rotate(10deg); &#125; .nav li &#123; position: relative; display: inline-block; padding: 0 16px; font-size: 13px; text-shadow: 1px 2px 4px rgba(0, 0, 0, .5); list-style: none outside none; /*使用伪元素制作导航列表项分隔线*/ background: no-repeat left/ 1px 15px linear-gradient(to right, #dd2926, #a82724); /*no-repeat 背景不会重复*/ &#125; /*删除第一项和最后一项导航分隔线*/ .nav li:first-child &#123; background: none; &#125; .nav a, .nav a:hover &#123; color: #fff; text-decoration: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="nav"&gt; &lt;li&gt;&lt;a href=""&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;About Me&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;Portfolio&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;Blog&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;Resources&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;Contact Me&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript之创建对象]]></title>
      <url>%2F2017%2F03%2F05%2F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[1.工厂模式:123456789101112function createPerson(name,age) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.sayame = function() &#123; alert(this.name); &#125;; return obj&#125;let person = createPerson('anson',20);person.name // ansonperson.age // 20 2.构造函数模式:(构造函数函数名开头大写)12345678910function Person(name,age) &#123; this.name = name; this.age = age; this.sayName = function() &#123; alert(this.name); &#125;;&#125;let person = new Person('anson',20);person1.name // ansonperson1.age // 20 3.原型模式:123456789function Person() &#123;&#125;Person.prototype.name = 'anson';Person.prototype.age = 20;Person.prototype.sayName = function() &#123; alert(this.name);&#125;;let person = new Person();person.name // ansonperson.age // 20 更简单的原型语法:12345678function Person() &#123;&#125;Person.prototype = &#123; name: 'anson'; age: 20; sayName: function () &#123; alert(this.name) &#125;&#125; 改变constructor指向:123456789function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: 'anson'; age: 20; sayName: function () &#123; alert(this.name) &#125;&#125; 4.组合使用构造函数模式和原型模式:12345678910111213141516171819202122function Person(name,age) &#123; this.name = name; this.age = age; this.color = ['yellow','blue'];&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name); &#125;&#125;let person1 = new Person('anson',20);let person2 = new Person('val',22);person1.color.push('red');person1.color // ["yellow", "blue", "red"]person2.color // ["yellow", "blue"]person1 === person2 // falseperson1.color === person2.color // falseperson1.sayName() === person2.sayName() // true 5.动态原型模式:123456789101112function Person(name,age) &#123; //属性 this.name = name; this.age = age;&#125;if(typeof this.sayName != "function") &#123; Person.prototype.sayName = function() &#123; alert(this.name) &#125;&#125;let person = new Person('Anson',20);person.sayName() // Anson 6.ES6 class:123456789101112131415class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; getName() &#123; return this.name; &#125; getAge() &#123; return this.age; &#125;&#125;const person = new Person("Anson",20);person.getName()//Anosn]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Object.defineproperties]]></title>
      <url>%2F2017%2F03%2F05%2FObject-defineproperties%2F</url>
      <content type="text"><![CDATA[和Object.defineProperty类似，只不过这个方法可以设置多个属性。继承defineproperty的参数 语法Object.defineProperties(obj, props,descriptor) 参数Object obj 目标对象String prop 需要定义的属性Object descriptor 该属性拥有的特性，可设置的值有： value 属性的值，默认为 undefined。 writable 该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），默认为 false。 get 一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。 set 一旦目标对象设置该属性，就会调用这个方法。默认为 undeinfed。 configurable 如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，默认为 false。 enumerable 是否能在for…in循环中遍历出来或在Object.keys中列举出来。默认为 false。1234567891011121314151617181920212223242526272829//用面向字面量的方式创建一个book对象var book=&#123;&#125;;//调用Object.defineProperties(对象名，要添加的属性)方法，为对象一次定义多个属性(1.数据属性)(2.访问器属性)Object.defineProperties(book,&#123;//添加的两个数据属性(_year,edition)_year:&#123;//(_year)前面的下划线表示只能通过对象方法访问的属性value:2004&#125;,edition:&#123;value:1&#125;,//添加了访问器属性(year)year:&#123;//调用get方法读取属性get:function()&#123;return this._year;&#125;,//调用set方法写入属性set:function(newValue)&#123;if (newValue&gt;2004) &#123;this._year=newValue;this.edition+=newValue-2004;&#125;&#125;&#125;&#125;);//测试book.year=2005;//访问器属性常见方式，设置一个属性的值会导致其他属性发生变化alert(book.edition);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Object.defineproperty]]></title>
      <url>%2F2017%2F03%2F05%2FObject-defineproperty%2F</url>
      <content type="text"><![CDATA[直接在一个对象上定义一个新的属性，或修改一个已经存在的属性。这个方法会返回该对象。 语法Object.defineProperty(obj, prop, descriptor) 参数Object obj 目标对象String prop 需要定义的属性Object descriptor 该属性拥有的特性，可设置的值有： value 属性的值，默认为 undefined。 writable 该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），默认为 false。 get 一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。 set 一旦目标对象设置该属性，就会调用这个方法。默认为 undeinfed。 configurable 如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，默认为 false。 enumerable 是否能在for…in循环中遍历出来或在Object.keys中列举出来。默认为 false。注意: ~ 在 descriptor 中不能同时设置访问器 (get 和 set) 和 wriable 或 value，否则会报错误]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript数组排序]]></title>
      <url>%2F2017%2F03%2F04%2FJavaScript%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[sort()方法ES6的写法:Array.sort((x, y) =&gt; x &gt; y ? 1 : -1)之前实在是太low…先创建比较函数12345678910111213//从小到大function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;let value = [1,5,2,15,11,8];let a = value.sort(compare);console.log(a);//[1, 2, 5, 8, 11, 15] 反之123456789function compare(value1,value2) &#123; if(value1 &lt; value2) &#123; return 1; &#125;else if(value1 &gt; value2) &#123; return -1; &#125;else &#123; return 0; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[递归算法]]></title>
      <url>%2F2017%2F03%2F04%2F%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[递归就是程序自己调用自己( recursion)一般来说,递归需要有边界条件、递归前进段和递归返回段12345678function a(num) &#123; if(num &lt;= 1) &#123; return 1; &#125;else &#123; return num * a(num-1) &#125;&#125;console.log(a(5)) //120 消除紧密耦合:12345678function a(num) &#123; if(num &lt;= 1) &#123; return 1; &#125;else &#123; return num * arguments.callee(num-1) &#125;&#125;console.log(a(5)) 为什么要消除耦合现象？123456789101112131415161718function factorial(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num-1); &#125; &#125; alert(factorial(5)); //输出120 factorial = function()&#123; return 0; &#125; alert(factorial(5)); //输出0//原因是return num * factorial(num-1)中调用的factorial函数被覆盖了 解决办法：12345678910111213141516171819function factorial(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125; &#125; alert(factorial(5)); //输出120 var trueFactorial = factorial; //赋值函数指针 factorial = function()&#123; return 0; &#125; alert(factorial(5)); //输出0；原因是return num * factorial(num-1);中调用的factorial函数被覆盖了 alert(trueFactorial(5)); //输出120]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript变量基础]]></title>
      <url>%2F2017%2F03%2F01%2FJavaScript%E5%8F%98%E9%87%8F%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[变量作用域 声明提前 作用域链 变量作用域变量分为全局变量和局部变量（在函数内部声明的变量为局部变量）一个变量的作用域（scope）是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在JavaScript代码中的任何地方都是有定义的。然而在函数内声明的变量只在函数体内有定义。它们是局部变量，作用域是局部性的。函数参数也是局部变量，它们只在函数体内有定义。 在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。 函数作用域和声明提前JavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。这意味着变量在声明之前就已经可用，JavaScript的这个特性被称为声明提前。(hoisting) 普通函数12345var i=10; function a() &#123; alert(i); &#125;; a(); 声明提前123456var i=10; function a() &#123; alert(i); var i = 2; &#125;; a(); 等同于123456var i = 10;function a() &#123; var i; //声明提前 alert(i); i = 2;&#125; 第一个代码正常输出了变量的值10，而第二个代码输出的却是undefined。 原因：在变量解析过程中首先查找局部的作用域，然后查找上层作用域。在代码一的函数当中没有定义变量i，于是查找上层作用域（全局作用域），进而进行输出其值。但是在代码二的函数内定义了变量i（无论是在alter之后还是之前定义变量，都认为在此作用域拥有变量i），于是不再向上层的作用域进行查找，直接输出i。但是不幸的是此时的局部变量i并没有赋值，所以输出的是undefined。 作用域链JavaScript是基于词法作用域的语言。全局变量在程序中始终都是有定义的。局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的。1234567891011121314var name="yellow";function fn()&#123; var name="blok"; function a()&#123; var name="red"; console.log(name); &#125; function b()&#123; console.log(name); &#125; a(); b(); &#125; fn(); 当执行a时，将创建函数a的执行环境(调用对象),并将该对象置于链表开头，然后将函数fn的调用对象链接在之后，最后是全局对象。然后从链表开头寻找变量name,作用域链是: a()-&gt;fn()-&gt;window,因为在a()上就找到了name的值red,所以name是”red”。但执行b()时，作用域链是： b()-&gt;fn()-&gt;window,所以name是”blok” 1. 解释：每一段js代码（全局代码或函数）都有一个与之关联的作用域链（scope chain）。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码中“作用域中”的变量。当js需要查找变量x的值的时候（这个过程称为变量解析（variable resolution）），它会从链的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中没有名为x的属性，js会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个，以此类推。如果作用域链上没有任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终抛出一个引用错误（ReferenceError）异常。 2. 作用域链举例：在js最顶层代码中（也就是不包括任何函数定义内的代码），作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域上至少有三个对象。 3. 作用域链创建规则：当定义一个函数时（注意:是定义的时候就开始了），它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来储存它的参数或局部变量，并将这个对象添加保存至那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来说，情况又有所变化：每次调用外部函数的时候，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都要微妙的差别—在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[患得患失 小起小落]]></title>
      <url>%2F2017%2F02%2F28%2F%E5%A4%AA%E5%B9%B4%E8%BD%BB%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[广积粮，高筑墙，缓称王]]></title>
      <url>%2F2017%2F02%2F28%2F%E5%8E%9F%E6%9D%A5%E6%88%91%E4%BB%80%E4%B9%88%E9%83%BD%E4%B8%8D%E4%BC%9A%2F</url>
      <content type="text"><![CDATA[急功好利，太过浮夸，没有坚持的决心，今天重新认识到缺点。目标：看完犀牛书，学好基础知识]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue Todo list 代码]]></title>
      <url>%2F2017%2F02%2F18%2FVue-Todo-list-%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[Vue初学123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div class="hello"&gt; &lt;h1 v-text="title"&gt;&lt;/h1&gt; &lt;input v-model="newItem" v-on:keyup.enter="addNew"&gt; &lt;ul&gt; &lt;li v-for="item in items" v-text="item.label" v-bind:class="&#123;items: item.isOk&#125;" v-on:click="onclick(item)"&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'hello', data () &#123; return &#123; title: 'this is a todo list', items: [], newItem: '' &#125; &#125;, methods: &#123; onclick: function (item) &#123; item.isOk = !item.isOk &#125;, addNew: function () &#123; this.items.push(&#123; label: this.newItem, isOk: false &#125;) this.newItem = '' &#125; &#125; &#125;&lt;/script&gt;&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.hello&#123; margin-top: 200px;&#125;.items&#123; text-decoration: line-through; &#125;ul,li&#123; list-style-type: none;&#125;&lt;/style&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap响应式表格]]></title>
      <url>%2F2017%2F02%2F18%2Fbootstrap%E5%93%8D%E5%BA%94%E5%BC%8F%E8%A1%A8%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[Bootstrap提供了一个容器，并且此容器设置类名“.table-responsive”,此容器就具有响应式效果，然后将置于这个容器当中，这样表格也就具有响应式效果 12345&lt;div class="table-responsive"&gt;&lt;table class="table table-bordered"&gt; …&lt;/table&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap紧凑型表格]]></title>
      <url>%2F2017%2F02%2F18%2Fbootstrap%E7%B4%A7%E5%87%91%E5%9E%8B%E8%A1%A8%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[紧凑型表格的运用，也只是需要在&lt;table class=&quot;table&quot;&gt;基础上添加类名“table-condensed”：123&lt;table class="table table-condensed"&gt;…&lt;/table&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap鼠标悬浮高亮的表格]]></title>
      <url>%2F2017%2F02%2F18%2Fbootstrap%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE%E9%AB%98%E4%BA%AE%E7%9A%84%E8%A1%A8%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[鼠标悬停高亮的表格使用也简单，仅需要&lt;table class=&quot;table&quot;&gt;元素上添加类名“table-hover”即可：123&lt;table class="table table-hover"&gt;…&lt;/table&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap带边框的表格]]></title>
      <url>%2F2017%2F02%2F18%2Fbootstrap%E5%B8%A6%E8%BE%B9%E6%A1%86%E7%9A%84%E8%A1%A8%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[Bootstrap中带边框的表格使用方法和斑马线表格的使用方法类似，只需要在基础表格&lt;table class=&quot;table&quot;&gt;基础上添加一个“.table-bordered”类名即可：123&lt;table class="table table-bordered"&gt; …&lt;/table&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap斑马线表格]]></title>
      <url>%2F2017%2F02%2F18%2Fbootstrap%E6%96%91%E9%A9%AC%E7%BA%BF%E8%A1%A8%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[Bootstrap在&lt;table class=&quot;table&quot;&gt;的基础上增加类名“.table-striped”即可：123&lt;table class="table table-striped"&gt;…&lt;/table&gt; 其效果与基础表格相比，仅是在tbody隔行有一个浅灰色的背景色。其实现原理也非常的简单，利用CSS3的结构性选择器“:nth-child”来实现，所以对于IE8以及其以下浏览器，没有背景条纹效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap基础表格]]></title>
      <url>%2F2017%2F02%2F18%2Fbootstrap%E5%9F%BA%E7%A1%80%E8%A1%A8%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[基础表格在Bootstrap中，对于基础表格是通过类名“.table”来控制。如果在&lt;table&gt;元素中不添加任何类名，表格是无任何样式效果的。想得到基础表格，我们只需要在&lt;table&gt;元素上添加“.table”类名，就可以得到Bootstrap的基础表格：123&lt;table class="table"&gt;…&lt;/table&gt; 表格的结构123456789101112131415&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;表格标题&lt;/th&gt;…&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;表格单元格&lt;/td&gt;…&lt;/tr&gt; …&lt;/tbody&gt;&lt;/table&gt; 示例：123456789101112131415161718192021&lt;table class="table"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap表格行的类]]></title>
      <url>%2F2017%2F02%2F18%2Fbootstrap%E8%A1%A8%E6%A0%BC%E8%A1%8C%E7%9A%84%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[Bootstrap还为表格的行元素&lt;tr&gt;提供了五种不同的类名，每种类名控制了行的不同背景颜色，具体说明如下表所示：示例：123&lt;tr class="active"&gt; &lt;td&gt;…&lt;/td&gt;&lt;/tr&gt; 实现悬浮状态，需要在&lt;table&gt;标签上加入table-hover类12345678910111213141516&lt;table class="table table-hover table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;类名&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class="active"&gt; &lt;td&gt;.active&lt;/td&gt; &lt;td&gt;表示当前活动的信息&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap表格]]></title>
      <url>%2F2017%2F02%2F18%2Fbootstrap%E8%A1%A8%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[表格行的类 基础表格.table 斑马线表格.table-striped 带边框的表格.table-bordered 鼠标悬浮高亮的表格.table-hover 紧凑型表格.table-condensed 响应式表格]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap排版]]></title>
      <url>%2F2017%2F02%2F18%2Fbootstrap%E6%8E%92%E7%89%88%2F</url>
      <content type="text"><![CDATA[副标题1&lt;h1&gt;Hello，world &lt;small&gt; bootstrap之旅&lt;/small&gt;&lt;/h1&gt; 强调内容1通过添加类名 .lead 实现 文本加粗1&lt;b&gt;和&lt;strong&gt; 斜体和正常1&lt;em&gt;和&lt;cite&gt; 强调相关的类 .text-muted：提示，使用浅灰色（#999） .text-primary：主要，使用蓝色（#428bca） .text-success：成功，使用浅绿色(#3c763d) .text-info：通知信息，使用浅蓝色（#31708f） .text-warning：警告，使用黄色（#8a6d3b） .text-danger：危险，使用褐色（#a94442）文本对齐风格☑ .text-left：左对齐☑ .text-center：居中对齐☑ .text-right：右对齐☑ .text-justify：两端对齐列表嵌套1234567891011&lt;ol&gt; &lt;li&gt;有序列表&lt;/li&gt; &lt;li&gt; 有序列表 &lt;ol&gt; &lt;li&gt;有序列表(2)&lt;/li&gt; &lt;li&gt;有序列表(2)&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;有序列表&lt;/li&gt;&lt;/ol&gt; 列表–去点列表1添加类名 .list-unstyled 列表–内联列表把垂直列表换成水平列表，而且去掉项目符号（编号），保持水平显示1添加类名 .list-inline 列表–定义列表调整了行间距，外边距和字体加粗效果1234&lt;dl&gt; &lt;dt&gt;ANSON&lt;/dt&gt;&lt;!--加粗--&gt; &lt;dd&gt;anson&lt;/dd&gt;&lt;!--正常--&gt;&lt;/dl&gt; 列表–水平定义列表给定义列表实现水平显示效果1&lt;dl&gt;添加类名 .dl-horizontal 三种代码风格：1、使用&lt;code&gt;&lt;/code&gt;来显示单行内联代码2、使用&lt;pre&gt;&lt;/pre&gt;来显示多行块代码3、使用&lt;kbd&gt;&lt;/kbd&gt;来显示用户输入代码以&amp;lt;开始，以&amp;gt;结束12345&lt;div&gt;Bootstrap的代码风格有三种： &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;kbd&amp;gt;&lt;/code&gt;&lt;/div&gt; pre元素一般用于显示大块的代码，并保证原有格式不变。但有时候代码太多，而且不想让其占有太大的页面篇幅，就想控制代码块的大小。Bootstrap也考虑到这一点，你只需要在pre标签上添加类名“.pre-scrollable”，就可以控制代码块区域最大高度为340px，一旦超出这个高度，就会在Y轴出现滚动条。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap基础]]></title>
      <url>%2F2017%2F02%2F18%2Fbootstrap%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[基本的Html模板123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap demo&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt; &lt;!--&lt;script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"&gt;&lt;/script&gt;--&gt; &lt;script src="../jquery/jquery-3.1.1.min.js"&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; bootstrap模板为使IE6、7、8版本（IE9以下版本）浏览器兼容html5新增的标签，引入下面代码文件即可1&lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt; 同理为使IE6、7、8版本浏览器兼容css3样式，引入下面代码：1&lt;script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[.ssh设置]]></title>
      <url>%2F2017%2F02%2F17%2Fssh%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[运行环境deepin 检查电脑是否有ssh key 存在 1ls -a .ssh 如果没有则 1ssh-keygen -t rsa -C "your emlie" 其他回车即可然后1cd .ssh 1dir 1vi id_rsa.pub]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM元素的获取index方法]]></title>
      <url>%2F2017%2F02%2F17%2FDOM%E5%85%83%E7%B4%A0%E7%9A%84%E8%8E%B7%E5%8F%96index%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.index()方法，从匹配的元素中搜索给定元素的索引值，从0开始计数 语法：参数接受一个jQuery或者dom对象作为查找的条件123.index().index( selector ).index( element ) 如果不传递任何参数给 .index() 方法，则返回值就是jQuery对象中第一个元素相对于它同辈元素的位置 如果在一组元素上调用 .index() ，并且参数是一个DOM元素或jQuery对象， .index() 返回值就是传入的元素相对于原先集合的位置 如果参数是一个选择器， .index() 返回值就是原先元素相对于选择器匹配元素的位置。如果找不到匹配的元素，则 .index() 返回 -1简单来说：123456&lt;ul&gt; &lt;a&gt;&lt;/a&gt; &lt;li id="test1"&gt;1&lt;/li&gt; &lt;li id="test2"&gt;2&lt;/li&gt; &lt;li id="test3"&gt;3&lt;/li&gt;&lt;/ul&gt; $(&quot;li&quot;).index() 没有传递参数，返回的结果是1，它的意思是返回同辈的排列循序，第一个li之前有a元素,同辈元素是a开始为0，所以li的开始索引是1如果要快速找到第二个li在列表中的索引,可以通过如下2种方式处理12$("li").index(document.getElementById("test2")) //结果：1$("li").index($("#test2")) //结果:1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM元素的获取get方法]]></title>
      <url>%2F2017%2F02%2F17%2FDOM%E5%85%83%E7%B4%A0%E7%9A%84%E8%8E%B7%E5%8F%96get%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[jQuery是一个合集对象，如果需要单独操作合集中的的某一个元素，可以通过.get()方法获取到以下有3个a元素结构：123&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt; 通过jQuery获取所有的a元素合集$(“a”)，如果想进一步在合集中找到第二2个dom元素单独处理，可以通过get方法语法：1.get( [index ] ) 注意 get方法是获取的dom对象，也就是通过document.getElementById获取的对象 get方法是从0开始索引所以第二个a元素的查找： 1$(a).get(1) 负索引值参数get方法还可以从后往前索引，传递一个负索引值，注意的负值的索引起始值是-1同样是找到第二元素，可以传递1$(a).get(-2)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[去空格神器trim方法]]></title>
      <url>%2F2017%2F02%2F17%2F%E5%8E%BB%E7%A9%BA%E6%A0%BC%E7%A5%9E%E5%99%A8trim%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[jQuery.trim()函数用于去除字符串两端的空白字符例如常见的登录信息的提交处理。用户的输入不一定是标准的，输入一段密码：’ 1123456 “，注意了： 密码的前后会留空，这可能是用户的无心的行为，但是密码确实又没错，针对这样的行为，应该要判断输入值的前后是否有空白符、换行符、制表符这样明显的无意义的输入值用法1$.trim($("ele")]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[查找数组中的索引inArray]]></title>
      <url>%2F2017%2F02%2F17%2F%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95inArray%2F</url>
      <content type="text"><![CDATA[等同ECMAScript5的indexOfjQuery.inArray()函数用于在数组中搜索指定的值，并返回其索引值。如果数组中不存在该值，则返回 -1。 语法：1jQuery.inArray( value, array ,[ fromIndex ] ) ECMAScript5中indexOf用法1234var str="Hello world!"document.write(str.indexOf("Hello") + "&lt;br /&gt;") //0document.write(str.indexOf("World") + "&lt;br /&gt;") //-1document.write(str.indexOf("world")) // 6 用法非常简单，传递一个检测的目标值，然后传递原始的数组，可以通过fromIndex规定查找的起始值，默认数组是0开始例如：在数组中查找值是5的索引1$.inArray(5,[1,2,3,4,5,6,7]) //返回对应的索引：4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[each方法的应用]]></title>
      <url>%2F2017%2F02%2F16%2Feach%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[jQuery中有个很重要的核心方法each，大部分jQuery方法在内部都会调用each，其主要的原因的就是jQuery的实例是一个元素合集jQuery的大部分方法都是针元素合集的操作，所以jQuery会提供$(selector).each()来遍历jQuery对象.each只是处理jQuery对象的方法，jQuery还提供了一个通用的jQuery.each方法，用来处理对象和数组的遍历 语法12jQuery.each(array, callback )jQuery.each( object, callback ) 第一个参数传递的就是一个对象或者数组，第二个是回调函数1234$.each(["anson", "安森"], function(index, value) &#123; //index是索引,也就是数组的索引 //value就是数组中的值了&#125;); each就是for循环方法的一个包装，内部就是通过for遍历数组与对象，通过回调函数返回内部迭代的一些参数，第一个参数是当前迭代成员在对象或数组中的索引值(从0开始计数)，第二个参数是当前迭代成员(与this的引用相同 jQuery.each()函数还会根据每次调用函数callback的返回值来决定后续动作。如果返回值为false，则停止循环(相当于普通循环中的break)；如果返回其他任何值，均表示继续执行下一个循环。123$.each(["anson", "安森"], function(index, value) &#123; return false; //停止迭代&#125;); 示例：123456789101112// 遍历数组元素$.each(['anson', '安森'], function(i, item) &#123; $anson.append("索引=" + i + " 元素=" + item);&#125;);//索引=0元素=anson 索引=1元素=安森// 遍历对象属性$.each(&#123; name: "anson", age: 18&#125;, function(property, value) &#123; $anson.append("属性名=" + property + "; 属性值=" + value);&#125;);//属性名=name属性值=anson 属性名=age属性值=18]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[停止动画stop]]></title>
      <url>%2F2017%2F02%2F16%2F%E5%81%9C%E6%AD%A2%E5%8A%A8%E7%94%BBstop%2F</url>
      <content type="text"><![CDATA[动画在执行过程中是允许被暂停的，当一个元素调用.stop()方法，当前正在运行的动画（如果有的话）立即停止 语法：12.stop( [clearQueue ], [ jumpToEnd ] ).stop( [queue ], [ clearQueue ] ,[ jumpToEnd ] ) stop可选的参数: .stop(); 停止当前动画，点击在暂停处继续开始 .stop(true); 如果同一元素调用多个动画方法，尚未被执行的动画被放置在元素的效果队列中。这些动画不会开始，直到第一个完成。当调用.stop()的时候，队列中的下一个动画立即开始。如果clearQueue参数提供true值,那么在队列中的动画其余被删除并永远不会运行 .stop(true,true); 当前动画将停止，但该元素上的 CSS 属性会被立刻修改成动画的目标值参考下面代码:123456789$("#anson").animate(&#123; height: 300&#125;, 5000)$("#anson").animate(&#123; width: 300&#125;, 5000)$("#anson").animate(&#123; opacity: 0.6&#125;, 2000) stop()：只会停止第一个动画，第二个第三个继续stop(true)：停止第一个、第二个和第三个动画stop(true ture)：停止动画，直接跳到第一个动画的最终状态12345678910111213141516171819202122232425262728//点击执行动画$("#exec").click(function()&#123; $("#anson").animate(&#123; height: 300 &#125;, 5000) $("#anson").animate(&#123; width: 300 &#125;, 5000) $("#anson").animate(&#123; opacity: 0.6 &#125;, 2000)&#125;)$("#stop").click(function() &#123; var v = $("#animation").val(); var $anson = $("#anson"); if (v == "1") &#123; //当前当前动画 $anson.stop() &#125; else if (v == "2") &#123; //停止所以队列 $anson.stop(true) &#125; else if (v == "3") &#123; //停止动画，直接跳到当前动画的结束 $anson.stop(true,true) &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[animate(下)]]></title>
      <url>%2F2017%2F02%2F16%2Fanimate-%E4%B8%8B%2F</url>
      <content type="text"><![CDATA[animate在执行动画中，如果需要观察动画的一些执行情况，或者在动画进行中的某一时刻进行一些其他处理，我们可以通过animate提供的第二种设置语法，传递一个对象参数，可以拿到动画执行状态一些通知1.animate( properties, options ) options参数 duration - 设置动画执行的时间 easing - 规定要使用的 easing 函数，过渡使用哪种缓动函数 step：规定每个动画的每一步完成之后要执行的函数 progress：每一次动画调用的时候会执行这个回调，就是一个进度的概念 complete：动画完成回调其中最关键的一点就是：如果多个元素执行动画，回调将在每个匹配的元素上执行一次，不是作为整个动画执行一次列出常用的方式12345678910111213$('#elem').animate(&#123; width: 'toggle', height: 'toggle' &#125;, &#123; duration: 5000, specialEasing: &#123; width: 'linear', height: 'easeOutBounce'&#125;, complete: function() &#123; $(this).after('&lt;div&gt;Animation complete.&lt;/div&gt;');&#125;&#125;); ```js$ele.animate({ height: ‘50’ }, { duration :2000, //每一个动画都会调用 step: function(now) { $aaron.text(‘高度的改变值:’+now) }})]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[animate]]></title>
      <url>%2F2017%2F02%2F16%2Fanimate%2F</url>
      <content type="text"><![CDATA[复杂的动画通过之前几个动画函数是不能够实现，这时候就需要强大的animate方法了操作一个元素执行3秒的淡入动画，对比一下2组动画设置的区别12345$(elem).fadeOut(3000) $(elem).animate(&#123; opacity:0&#125;,3000) 语法：12.animate( properties ,[ duration ], [ easing ], [ complete ] ).animate( properties, options ) .animate()方法允许我们在任意的数值的CSS属性上创建动画。2种语法使用，几乎差不多了，唯一必要的属性就是一组CSS属性键值对。这组属性和用于设置.css()方法的属性键值对类似，除了属性范围做了更多限制。第二个参数开始可以单独传递多个实参也可以合并成一个对象传递了 参数分解：properties：一个或多个css属性的键值对所构成的Object对象。要特别注意所有用于动画的属性必须是数字的，除非另有说明；这些属性如果不是数字的将不能使用基本的jQuery功能。比如常见的，border、margin、padding、width、height、font、left、top、right、bottom、wordSpacing等等这些都是能产生动画效果的。background-color很明显不可以，因为参数是red或者GBG这样的值，非常用插件，否则正常情况下是不能只用动画效果的。注意，CSS 样式使用 DOM 名称（比如 “fontSize”）来设置，而非 CSS 名称（比如 “font-size”）。特别注意单位，属性值的单位像素（px）,除非另有说明。单位em 和 %需要指定使用123456.animate(&#123; left: 50, width: '50px' opacity: 'show', fontSize: "10em",&#125;, 500); 除了定义数值，每个属性能使用’show’, ‘hide’, 和 ‘toggle’。这些快捷方式允许定制隐藏和显示动画用来控制元素的显示或隐藏123.animate(&#123; width: "toggle"&#125;); 如果提供一个以+= 或 -=开始的值，那么目标值就是以这个属性的当前值加上或者减去给定的数字来计算的123.animate(&#123; left: '+=50px'&#125;, "slow"); duration时间动画执行的时间，持续时间是以毫秒为单位的；值越大表示动画执行的越慢，不是越快。还可以提供’fast’ 和 ‘slow’字符串，分别表示持续时间为200 和 600毫秒。 easing动画运动的算法jQuery库中默认调用 swing。如果需要其他的动画算法，请查找相关的插件 complete回调动画完成时执行的函数，这个可以保证当前动画确定完成后发会触发示例：1234567891011&lt;style&gt;p &#123; color: red;&#125;div&#123; width:200px; height: 100px; background-color: yellow; color:red;&#125;&lt;/style&gt; 123456789&lt;div id="aaron"&gt;内部动画&lt;/div&gt; 点击观察动画效果： &lt;select id="animation"&gt; &lt;option value="1"&gt;动画1&lt;/option&gt; &lt;option value="2"&gt;动画2&lt;/option&gt; &lt;option value="3"&gt;动画3&lt;/option&gt; &lt;option value="4"&gt;动画4&lt;/option&gt; &lt;/select&gt;&lt;input id="exec" type="button" value="执行动画"&gt; 12345678910111213141516171819202122232425262728$("#exec").click(function() &#123; var v = $("#animation").val(); var $aaron = $("#aaron"); if (v == "1") &#123; // 数值的单位默认是px $aaron.animate(&#123; width :300, height :300 &#125;); &#125; else if (v == "2") &#123; // 在现有高度的基础上增加100px $aaron.animate(&#123; width : "+=100px", height : "+=100px" &#125;); &#125; else if (v == "3") &#123; $aaron.animate(&#123; fontSize: "5em" &#125;, 2000, function() &#123; alert("动画 fontSize执行完毕!"); &#125;); &#125; else if (v == "4") &#123; //通过toggle参数切换高度 $aaron.animate(&#123; width: "toggle" &#125;); &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[淡入效果fadeTo]]></title>
      <url>%2F2017%2F02%2F16%2F%E6%B7%A1%E5%85%A5%E6%95%88%E6%9E%9CfadeTo%2F</url>
      <content type="text"><![CDATA[淡入淡出fadeIn与fadeOut都是修改元素样式的opacity属性，但是他们都有个共同的特点，变化的区间要么是0，要么是1fadeIn：淡入效果，内容显示，opacity是0到1fadeOut：淡出效果，内容隐藏，opacity是1到0fadeTo： 自定义透明度 语法1.fadeTo( duration, opacity ,callback) 必需的 duration参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。fadeTo() 方法中必需的 opacity 参数将淡入淡出效果设置为给定的不透明度（值介于 0 与 1 之间）。可选的 callback 参数是该函数完成后所执行的函数名称。1$("p").fadeTo(1000, 0.2);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[淡入淡出切换fadeToggle]]></title>
      <url>%2F2017%2F02%2F16%2F%E6%B7%A1%E5%85%A5%E6%B7%A1%E5%87%BA%E5%88%87%E6%8D%A2fadeToggle%2F</url>
      <content type="text"><![CDATA[fadeToggle()函数用于切换所有匹配的元素，并带有淡入/淡出的过渡动画效果1.fadeToggle( [duration ] ,[ complete ] ) 可选的 duration 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是 fadeToggle完成后所执行的函数名称。fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换。如果元素已淡出，则 fadeToggle() 会向元素添加淡入效果。如果元素已淡入，则 fadeToggle() 会向元素添加淡出效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[淡入动画fadeIn]]></title>
      <url>%2F2017%2F02%2F16%2F%E6%B7%A1%E5%85%A5%E5%8A%A8%E7%94%BBfadeIn%2F</url>
      <content type="text"><![CDATA[fadeOut是淡出效果，相反的还有淡入效果fadeIn,方法使用上两者都是一致的，只是结果相反1.fadeIn( [duration ], [ complete ] ) duration：指定过渡动画运行多长时间(毫秒数)，默认值为400。该参数也可以为字符串”fast”(=200)或”slow”(=600)。 元素显示完毕后需要执行的函数。函数内的this指向当前DOM元素。 fadeIn()函数用于显示所有匹配的元素，并带有淡入的过渡动画效果。注意： 淡入的动画原理：操作元素的不透明度从0%逐渐增加到100% 如果元素本身是可见的，不对其作任何改变。如果元素是隐藏的，则使其可见]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[淡出动画fadeOut]]></title>
      <url>%2F2017%2F02%2F16%2F%E6%B7%A1%E5%87%BA%E5%8A%A8%E7%94%BBfadeOut%2F</url>
      <content type="text"><![CDATA[fadeOut()函数用于隐藏所有匹配的元素，并带有淡出的过渡动画效果1.fadeOut( [duration ], [ complete ] ) 1$("p").fadeOut("1000");]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[上卷下拉切换slideToggle]]></title>
      <url>%2F2017%2F02%2F16%2F%E4%B8%8A%E5%8D%B7%E4%B8%8B%E6%8B%89%E5%88%87%E6%8D%A2slideToggle%2F</url>
      <content type="text"><![CDATA[基本的操作：slideToggle()这是最基本的操作，获取元素的高度，使这个元素的高度发生改变，从而让元素里的内容往下或往上滑。提供参数：.slideToggle( [duration ] ,[ complete ] )同样的提供了时间、还有动画结束的回调。在参数对应的时间内，元素会完成动画，然后出发回调函数同时也提供了时间的快速定义，字符串 ‘fast’ 和 ‘slow’ 分别代表200和600毫秒的延时12slideToggle("fast") slideToggle("slow") 注意： display属性值保存在jQuery的数据缓存中，所以display可以方便以后可以恢复到其初始值 当一个隐藏动画后，高度值达到0的时候，display 样式属性被设置为none，以确保该元素不再影响页面布局]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[上卷动画slideUp]]></title>
      <url>%2F2017%2F02%2F16%2F%E4%B8%8A%E5%8D%B7%E5%8A%A8%E7%94%BBslideUp%2F</url>
      <content type="text"><![CDATA[.slideDown()：用滑动动画显示一个匹配元素 .slideDown()方法将给匹配元素的高度的动画，这会导致页面的下面部分滑下去，弥补了显示的方式常见的操作，提供一个动画是时间，然后传递一个回调，用于知道动画是什么时候结束.slideDown( [duration ],[complete ] )持续时间（duration）是以毫秒为单位的，数值越大，动画越慢，不是越快。字符串 ‘fast’ 和 ‘slow’ 分别代表200和600毫秒的延时。如果提供任何其他字符串，或者这个duration参数被省略，那么默认使用400 毫秒的延时。具体使用：123$("ele").slideDown(1000, function() &#123; //等待动画执行1秒后,执行别的动作....&#125;); 注意事项： 下拉动画是从无到有，所以一开始元素是需要先隐藏起来的，可以设置display:none 如果提供回调函数参数，callback会在动画完成的时候调用。将不同的动画串联在一起按顺序排列执行是非常有用的。这个回调函数不设置任何参数，但是 this会设成将要执行动画的那个DOM元素，如果多个元素一起做动画效果，那么要非常注意，回调函数会在每一个元素执行完动画后都执行一次，而不是这组 动画整体才执行一次]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[下拉动画slideDown]]></title>
      <url>%2F2017%2F02%2F16%2F%E4%B8%8B%E6%8B%89%E5%8A%A8%E7%94%BBslideDown%2F</url>
      <content type="text"><![CDATA[.slideDown()：用滑动动画显示一个匹配元素 .slideDown()方法将给匹配元素的高度的动画，这会导致页面的下面部分滑下去，弥补了显示的方式常见的操作，提供一个动画是时间，然后传递一个回调，用于知道动画是什么时候结束 .slideDown( [duration ],[complete ] ) 持续时间（duration）是以毫秒为单位的，数值越大，动画越慢，不是越快。字符串 ‘fast’ 和 ‘slow’ 分别代表200和600毫秒的延时。如果提供任何其他字符串，或者这个duration参数被省略，那么默认使用400 毫秒的延时。具体使用：123$("ele").slideDown(1000, function() &#123; //等待动画执行1秒后,执行别的动作....&#125;); 注意事项： 下拉动画是从无到有，所以一开始元素是需要先隐藏起来的，可以设置display:none 如果提供回调函数参数，callback会在动画完成的时候调用。将不同的动画串联在一起按顺序排列执行是非常有用的。这个回调函数不设置任何参数，但是 this会设成将要执行动画的那个DOM元素，如果多个元素一起做动画效果，那么要非常注意，回调函数会在每一个元素执行完动画后都执行一次，而不是这组动画整体才执行一次]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[显示与隐藏切换toggle方法]]></title>
      <url>%2F2017%2F02%2F16%2F%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F%E5%88%87%E6%8D%A2toggle%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[toggle用于切换显示或隐藏匹配元素 基本的操作：.toggle() 如果元素是最初显示，它会被隐藏 如果隐藏的，它会显示出来提供参数：.toggle( [duration ] [complete ] )直接定位：.toggle(display)直接提供一个参数，指定要改变的元素的最终效果其实就是确定是使用show还是hide方法12345if ( display === true ) &#123; $( "elem" ).show();&#125; else if ( display === false ) &#123; $( "elem" ).hide();&#125; 代码：12$("div").toggle(3000)//3000毫秒后隐藏]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[显示元素的show方法]]></title>
      <url>%2F2017%2F02%2F16%2F%E6%98%BE%E7%A4%BA%E5%85%83%E7%B4%A0%E7%9A%84show%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[类似于display:block1$('elem').hide(3000).show(3000) 让元素执行3秒的隐藏动画，然后执行3秒的显示动画 注意事项： show与hide方法是修改的display属性，通过是visibility属性布局需要通过css方法单独设置 如果使用!important在你的样式中，比如display: none !important，如果你希望.show()方法正常工作，必须使用.css(‘display’, ‘block !important’)重写样式 如果让show与hide成为一个动画，那么默认执行动画会改变元素的高度，高度，透明度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[隐藏元素的hide方法]]></title>
      <url>%2F2017%2F02%2F16%2F%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84hide%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[类似于设置css的display为none属性1$elem.hide() 提供参数：1.hide( options ) 当提供hide方法一个参数时，.hide()就会成为一个动画方法。.hide()方法将会匹配元素的宽度，高度，以及不透明度，同时进行动画操作 快捷参数：1.hide("fast / slow") 这是一个动画设置的快捷方式，’fast’ 和 ‘slow’ 分别代表200和600毫秒的延时，就是元素会执行200/600毫秒的动画后再隐藏代码：123 $("div").hide( 3000,function() &#123; alert('执行3000ms动画完毕')&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基础动画效果]]></title>
      <url>%2F2017%2F02%2F16%2F%E5%9F%BA%E7%A1%80%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[jQuery动画 1.动画基础隐藏和显示 隐藏元素的hide方法 显示元素的show方法 显示与隐藏切换toggle方法 2.上卷下拉效果 下拉动画slideDown 上卷动画slideUp 上卷下拉切换slideToggle 3.淡入淡出效果 淡出动画fadeOut 淡入动画fadeIn 淡入淡出切换fadeToggle 淡入效果fadeTo 4.自定义动画 animate(上) animate(下) 停止动画stop 5.jQuery核心 each方法的应用 查找数组中的索引inArray 去空格神器trim方法 DOM元素的获取get方法 DOM元素的获取index方法git]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[triggerHandler事件]]></title>
      <url>%2F2017%2F02%2F16%2FtriggerHandler%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[trigger事件还有一个特性：会在DOM树上冒泡，所以如果要阻止冒泡就需要在事件处理程序中返回false或调用事件对象中的.stopPropagation() 方法可以使事件停止冒泡trigger事件是具有触发原生与自定义能力的，但是存在一个不可避免的问题： 事件对象event无法完美的实现，毕竟一个是浏览器给的，一个是自己模拟的。尽管 .trigger() 模拟事件对象，但是它并没有完美的复制自然发生的事件，若要触发通过 jQuery 绑定的事件处理函数，而不触发原生的事件，使用.triggerHandler() 来代替 triggerHandler与trigger的用法是一样的，重点看不同之处： triggerHandler不会触发浏览器的默认行为，.triggerHandler( “submit” )将不会调用表单上的.submit() .trigger() 会影响所有与 jQuery 对象相匹配的元素，而 .triggerHandler() 仅影响第一个匹配到的元素 使用 .triggerHandler() 触发的事件，并不会在 DOM 树中向上冒泡。 如果它们不是由目标元素直接触发的，那么它就不会进行任何处理 与普通的方法返回 jQuery 对象(这样就能够使用链式用法)相反，.triggerHandler() 返回最后一个处理的事件的返回值。如果没有触发任何事件，会返回 undefined]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[trigger事件]]></title>
      <url>%2F2017%2F02%2F16%2Ftrigger%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[.trigger()根据绑定到匹配元素的给定的事件类型执行所有的处理程序和行为在jQuery通过on方法绑定一个原生事件123$('#elem').on('click', function() &#123; alert("触发系统事件") &#125;); alert需要执行的条件：必须有用户点击才可以。如果不同用户交互是否能在某一时刻自动触发该事件呢？ 正常来说是不可以的，但是jQuery解决了这个问题，提供了一个trigger方法来触发浏览器事件 所以我们可以这样： 1$('#elem').trigger('click'); 在绑定on的事件元素上，通过trigger方法就可以调用到alert trigge支持自定义事件，并且自定义时间还支持传递参数1234$('#elem').on('Aaron', function(event,arg1,arg2) &#123; alert("自触自定义时间") &#125;);$('#elem').trigger('Aaron',['参数1','参数2'])]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义事件]]></title>
      <url>%2F2017%2F02%2F16%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[trigger事件 triggerHandler事件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery事件对象的属性和方法]]></title>
      <url>%2F2017%2F02%2F16%2FjQuery%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[常用的事件对象的属于与方法 event.type：获取事件的类型触发元素的事件类型123$("a").click(function(event) &#123; alert(event.type); // "click"事件&#125;); event.pageX 和 event.pageY：获取鼠标当前相对于页面的坐标通过这2个属性，可以确定元素在当前页面的坐标值，鼠标相对于文档的左边缘的位置（左边）与 （顶边）的距离，简单来说是从页面左上角开始,即是以页面为参考点,不随滑动条移动而变化 event.preventDefault() 方法：阻止默认行为这个用的特别多，在执行这个方法后，如果点击一个链接（a标签），浏览器不会跳转到新的 URL 去了。我们可以用 event.isDefaultPrevented() 来确定这个方法是否(在那个事件对象上)被调用过了 event.stopPropagation() 方法：阻止事件冒泡事件是可以冒泡的，为防止事件冒泡到DOM树上，也就是不触发的任何前辈元素上的事件处理函数 event.which：获取在鼠标单击时，单击的是鼠标的哪个键event.which 将 event.keyCode 和 event.charCode 标准化了。event.which也将正常化的按钮按下(mousedown 和 mouseupevents)，左键报告1，中间键报告2，右键报告3 event.currentTarget : 在事件冒泡过程中的当前DOM元素冒泡前的当前触发事件的DOM对象, 等同于this. this和event.target的区别：js中事件是会冒泡的，所以this是可以变化的，但event.target不会变化，它永远是直接接受事件的目标DOM元素；.this和event.target都是dom对象如果要使用jquey中的方法可以将他们转换为jquery对象。比如this和$(this)的使用、event.target和$(event.target)的使用；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery事件对象的作用]]></title>
      <url>%2F2017%2F02%2F16%2FjQuery%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
      <content type="text"><![CDATA[一个标准的”click”点击事件123$(elem).on("click",function(event)&#123; event //事件对象&#125;) 12345678910&lt;ul&gt; &lt;li&gt;点击：触发一&lt;/li&gt; &lt;!--触发的元素是内容是:点击：触发一--&gt; &lt;li&gt;点击：触发二&lt;/li&gt; &lt;!--触发的元素是内容是:点击：触发二--&gt; &lt;li&gt;点击：触发三&lt;/li&gt; &lt;!--触发的元素是内容是:点击：触发三--&gt; &lt;li&gt;点击：触发四&lt;/li&gt; &lt;!--触发的元素是内容是:点击：触发四--&gt; &lt;/ul&gt; 1234//多事件绑定$("ul").on('click',function(e)&#123; alert('触发的元素是内容是: ' + e.target.textContent)&#125;) event.targettarget 属性可以是注册事件时的元素，或者它的子元素。通常用于比较 event.target 和 this 来确定事件是不是由于冒泡而触发的。经常用于事件冒泡时处理事件委托简单来说：event.target代表当前触发事件的元素，可以通过当前元素对象的一系列属性来判断是不是我们想要的元素]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[事件对象的使用]]></title>
      <url>%2F2017%2F02%2F16%2F%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[jQuery事件对象的作用 jQuery事件对象的属性和方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[卸载事件off()方法]]></title>
      <url>%2F2017%2F02%2F16%2F%E5%8D%B8%E8%BD%BD%E4%BA%8B%E4%BB%B6off-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[通过.on()绑定的事件处理程序 通过off() 方法移除该绑定 根据on绑定事件的一些特性，off方法也可以通过相应的传递组合的事件名，名字空间，选择器或处理函数来移除绑定在元素上指定的事件处理函数。当有多个过滤参数时，只有与这些参数完全匹配的事件处理函数才会被移除绑定2个事件1$("elem").on("mousedown mouseup",fn) 删除一个事件1$("elem").off("mousedown") 删除所有事件1$("elem").off("mousedown mouseup") 快捷方式删除所有事件，这里不需要传递事件名了，节点上绑定的所有事件讲全部销毁1$("elem").off()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[on()的高级用法]]></title>
      <url>%2F2017%2F02%2F16%2Fon-%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[on的另一个事件机制委托的机制 委托机制1.on( events ,[ selector ] ,[ data ], handler(eventObject) ) 在on的第二参数中提供了一个selector选择器，简单的来描述下参考下面3层结构12345&lt;div class="left"&gt; &lt;p class="aaron"&gt; &lt;a&gt;目标节点&lt;/a&gt; //点击在这个元素上 &lt;/p&gt;&lt;/div&gt; 给出如下代码：1$("div").on("click","p",fn) 事件绑定在最上层div元素上，当用户触发在a元素上，事件将往上冒泡，一直会冒泡在div元素上。如果提供了第二参数，那么事件在往上冒泡的过程中遇到了选择器匹配的元素，将会触发事件回调函数示例：12345&lt;div class="left"&gt; &lt;div class="aaron"&gt; &lt;a&gt;点击这里&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 123456//给body绑定一个click事件//没有直接a元素绑定点击事件//通过委托机制，点击a元素的时候，事件触发$('body').on('click', 'a', function(e) &#123; alert(e.target.textContent)&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[on()的多事件绑定]]></title>
      <url>%2F2017%2F02%2F16%2Fon-%E7%9A%84%E5%A4%9A%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
      <content type="text"><![CDATA[基本用法：.on( events ,[ selector ] ,[ data ] )最常见的给元素绑定一个点击事件，对比一下快捷方式与on方式的不同12$("#elem").click(function()&#123;&#125;) //快捷方式$("#elem").on('click',function()&#123;&#125;) //on方式 最大的不同点就是on是可以自定义事件名 多个事件绑定同一个函数1$("#elem").on("mouseover mouseout",function()&#123; &#125;); 通过空格分离，传递不同的事件名，可以同时绑定多个事件 多个事件绑定不同函数1234$("#elem").on(&#123; mouseover:function()&#123;&#125;, mouseout:function()&#123;&#125;,&#125;); 通过空格分离，传递不同的事件名，可以同时绑定多个事件，每一个事件执行自己的回调方法 将数据传递到处理程序123456function greet( event ) &#123; alert( "Hello " + event.data.name ); //Hello anson&#125;$( "button" ).on( "click", &#123; name: "anson"&#125;, greet ); 可以通过第二参数（对象），当一个事件被触发时，要传递给事件处理函数的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[事件的绑定和解绑]]></title>
      <url>%2F2017%2F02%2F16%2F%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%91%E5%AE%9A%E5%92%8C%E8%A7%A3%E7%BB%91%2F</url>
      <content type="text"><![CDATA[on()的多事件绑定 on()的高级用法 卸载事件off()方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[keypress()事件]]></title>
      <url>%2F2017%2F02%2F16%2Fkeypress-%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[在input元素上绑定keydown事件会发现一个问题：每次获取的内容都是之前输入的，当前输入的获取不到 keypress事件与keydown和keyup的主要区别 只能捕获单个字符，不能捕获组合键 无法响应系统功能键（如delete，backspace） 不区分小键盘和主键盘的数字字符总而言之，KeyPress主要用来接收字母、数字等ANSI字符，而 KeyDown 和 KeyUP 事件过程可以处理任何不被 KeyPress 识别的击键。诸如：功能键（F1-F12）、编辑键、定位键以及任何这些键和键盘换档键的组合等。用法：1234567//直接绑定事件$elem.keypress( handler(eventObject) )//传递参数$elem.keypress( [eventData ], handler(eventObject) )//手动触发已绑定的事件$elem.keypress()代码： 123456&lt;div class="left"&gt; &lt;div class="aaron"&gt;监听keypress输入: &lt;input class="target1" type="text" value="" /&gt;&lt;br /&gt; 输入中文测试，无法显示:&lt;em&gt;&lt;/em&gt; &lt;/div&gt;&lt;/div&gt; 12345//监听键盘按键//获取输入的值$('.target1').keypress(function(e) &#123; $("em").text(e.target.value)&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[keydown()与keyup()事件]]></title>
      <url>%2F2017%2F02%2F16%2Fkeydown-%E4%B8%8Ekeyup-%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[键盘按下与松手，对应keydown与keyup方法来监听 keydown事件：当用户在一个元素上第一次按下键盘上字母键的时候，就会触发它。使用上非常简单，与基本事件参数处理保持一致，这里使用不在重复了，列出使用的方法123456//直接绑定事件$elem.keydown( handler(eventObject) )//传递参数$elem.keydown( [eventData ], handler(eventObject) )//手动触发已绑定的事件$elem.keydown() keyup事件：当用户在一个元素上第一次松手键盘上的键的时候，就会触发它。使用方法与keydown是一致的只是触发的条件是方法的代码：123456789&lt;div&gt;监听keydown输入: &lt;input class="target1" type="text" value="" /&gt;&lt;br /&gt; 按下显示输入的值:&lt;em&gt;&lt;/em&gt;&lt;/div&gt; &lt;div&gt;监听keyup输入: &lt;input class="target2" type="text" value="" /&gt;&lt;br /&gt; 松手显示输入的值:&lt;em&gt;&lt;/em&gt;&lt;/div&gt; 1234567891011//监听键盘按键//获取输入的值$('.target1').keydown(function(e) &#123; $("em:first").text(e.target.value)&#125;);//监听键盘按键//获取输入的值$('.target2').keyup(function(e) &#123; $("em:last").text(e.target.value)&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery键盘事件]]></title>
      <url>%2F2017%2F02%2F16%2FjQuery%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[keydown()与keyup()事件keydown(按下)|keyup(松开) keypress()事件keypress类似于keydown]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[submit事件]]></title>
      <url>%2F2017%2F02%2F16%2Fsubmit%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[在表单提交的时候过滤一些的数据、做一些必要的操作（例如：验证表单输入的正确性，如果错误就阻止提交，从新输入）此时可以通过submit事件，监听下提交表单的这个动作 方法一：$ele.submit()绑定$ele元素，不带任何参数一般是用来指定触发一个事件，用的比较少1&lt;div id="test"&gt;点击触发&lt;div&gt; 123456$("ele").submit(function()&#123; alert('触发指定事件')&#125;)$("#text").click(function()&#123; $("ele").submit() //指定触发事件 &#125;); 方法二：$ele.submit( handler(eventObject) )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了123&lt;form id="target" action="destination.html"&gt; &lt;input type="submit" value="Go" /&gt;&lt;/form&gt; 123$("#target").submit(function() &#123; //绑定提交表单触发 //this指向 from元素 &#125;); 方法三：$ele.submit( [eventData ], handler(eventObject) )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题123&lt;form id="target" action="destination.html"&gt; &lt;input type="submit" value="Go" /&gt;&lt;/form&gt; 123$("#target").submit(11111,function(data) &#123; //绑定提交表单触发 //data =&gt; 1111 //传递的data数据&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[select事件]]></title>
      <url>%2F2017%2F02%2F16%2Fselect%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件这个函数会调用执行绑定到select事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为 方法一：.select()触发元素的select事件:1$("input").select(); 方法二：$ele.select( handler(eventObject) )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了1&lt;input id="test" value="文字选中"&gt;&lt;/input&gt; 123$("#test").select(function() &#123; //响应文字选中回调 //this指向 input元素 &#125;); 方法三：$ele.select( [eventData ], handler(eventObject) )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题1&lt;input id="test" value="文字选中"&gt;&lt;/input&gt; 1234$("#test").select(11111,function(e) &#123;//响应文字选中回调 //this指向 div元素 //e.date =&gt; 11111 传递数据&#125;); 代码:12345678910//监听input元素中value的选中//触发元素的select事件$("input").select(function(e)&#123; alert(e.target.value)&#125;)//监听textarea元素中value的选中$('textarea').select(function(e) &#123; alert(e.target.value);&#125;); 代码：1234567891011121314&lt;div class="aaron"&gt; &lt;form id="target1" action="test.html"&gt; 回车键或者点击提交表单： &lt;input type="text" value="输入新的值" /&gt; &lt;input type="submit" value="Go" /&gt; &lt;/form&gt;&lt;/div&gt;&lt;div class="aaron"&gt; &lt;form id="target2" action="destination.html"&gt; 回车键或者点击提交表单,禁止浏览器默认跳转： &lt;input type="text" value="输入新的值" /&gt; &lt;input type="submit" value="Go" /&gt; &lt;/form&gt;&lt;/div&gt; 123456789//回车键或者点击提交表单$('#target1').submit(function(e) &#123; alert('捕获提交表达动作,不阻止页面跳转')&#125;);//回车键或者点击提交表单,禁止浏览器默认跳转：$('#target2').submit(function() &#123; alert('捕获提交表达动作,阻止页面跳转') return false;&#125;); 通过在form元素上绑定submit事件，可以监听到用户的提交表单的的行为具体能触发submit事件的行为：12341. &lt;input type="submit"&gt;2. &lt;input type="image"&gt;3. &lt;button type="submit"&gt;4. 当某些表单元素获取焦点时，敲击Enter（回车键） 注意：form元素是有默认提交表单的行为，如果通过submit处理的话，需要禁止浏览器的这个默认行为传统的方式是调用事件对象 e.preventDefault() 来处理， jQuery中可以直接在函数中最后结尾return false即可jQuery处理如下：123$("#target").submit(function(data) &#123; return false; //阻止默认行为，提交表单&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[change事件]]></title>
      <url>%2F2017%2F02%2F15%2Fchange%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[input元素，textarea和select元素的值都是可以发生改变的，通过change事件去监听这些改变的动作 注释：当用于 select 元素时，change 事件会在选择某个选项时发生。当用于 textfield 或 textarea 时，该事件会在元素失去焦点时发生 input元素监听value值的变化，当有改变时，失去焦点后触发change事件。对于单选按钮和复选框，当用户用鼠标做出选择时，该事件立即触发。 select元素对于下拉选择框，当用户用鼠标作出选择时，该事件立即触发 textarea元素多行文本输入框，当有改变时，失去焦点后触发change事件12345678910111213141516171819&lt;div class="left"&gt; //监听input的改变 &lt;div class="aaron"&gt;input： &lt;input class="target1" type="text" value="监听input的改变" /&gt; &lt;/div&gt; //监听select的改变 &lt;div class="aaron1"&gt;select： &lt;select class="target2"&gt; &lt;option value="option1" selected="selected"&gt;Option 1&lt;/option&gt; &lt;option value="option2"&gt;Option 2&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; //监听textarea的改变 &lt;div class="aaron3"&gt;textarea： &lt;textarea class="target2" rows="3" cols="20"&gt;多行的文本输入控件&lt;/textarea&gt; &lt;/div&gt;&lt;/div&gt; 输出结果： &lt;div id="result"&gt;&lt;/div&gt; 1234567891011121314//监听input值的改变 $('.target1').change(function(e) &#123; $("#result").html(e.target.value) &#125;); //监听select： $(".target2").change(function(e) &#123; $("#result").html(e.target.value) &#125;) //监听textarea： $(".target3").change(function(e) &#123; $("#result").html(e.target.value) &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[blur与focus事件]]></title>
      <url>%2F2017%2F02%2F15%2Fblur%E4%B8%8Efocus%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[focusin事件,focusout事件与focus,blur事件聚焦focus 失焦blur 区别：是否支持冒泡处理例子123&lt;div&gt; &lt;input type="text" /&gt;&lt;/div&gt; 其中input元素可以触发focus()事件div是input的父元素，当它包含的元素input触发了focus事件时，它就产生了focusin()事件。focus()在元素本身产生，focusin()在元素包含的元素中产生blur与focusout也亦是如此]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery表单事件]]></title>
      <url>%2F2017%2F02%2F15%2FjQuery%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[focusin事件监听聚焦事件 focusout事件监听失焦事件 blur与focus事件监听表单焦点(聚焦|失焦) change事件监听输入域动作 select事件监听鼠标选中事件 submit事件监听下提交表单动作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[focusout事件]]></title>
      <url>%2F2017%2F02%2F15%2Ffocusout%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[当一个元素，或者其内部任何一个元素失去焦点的时候，比如input元素，用户在点击失去焦的时候，如果开发者需要捕获这个动作，jQuery提供了一个focusout事件 方法一：$ele.focusout()绑定$ele元素，不带任何参数一般是用来指定触发一个事件，可能一般用的比较少1&lt;div id="test"&gt;点击触发&lt;div&gt; 123456$("ele").focusout(function()&#123; alert('触发指定事件')&#125;)$("#test").mouseup(function()&#123; $("ele").focusout() //指定触发事件 &#125;); 方法二：$ele.focusout( handler )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了1&lt;div id="test"&gt;点击触发&lt;div&gt; 123$("#test").focusout(function() &#123; //this指向 div元素&#125;); 代码:12345//input失去焦点//给input元素增加一个边框$("input:first").focusout(function() &#123; $(this).css('border','2px solid red')&#125;) 方法三：$ele.focusout( [eventData ], handler )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题1&lt;div id="test"&gt;点击触发&lt;div&gt; 1234$("#test").focusout(11111,function(e) &#123; //this指向 div元素 //e.date =&gt; 11111 传递数据&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[focusin事件]]></title>
      <url>%2F2017%2F02%2F15%2Ffocusin%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[当一个元素，或者其内部任何一个元素获得焦点的时候，例如：input元素，用户在点击聚焦的时候，如果开发者需要捕获这个动作的时候，jQuery提供了一个focusin事件 方法一：$ele.focusin()绑定$ele元素，不带任何参数一般是用来指定触发一个事件，一般用的比较少1&lt;div id="test"&gt;点击触发&lt;div&gt; 123456$("ele").focusin(function()&#123; alert('触发指定事件')&#125;)$("#test").mouseup(function()&#123; $("ele").focusin() //指定触发事件 &#125;); 方法二：$ele.focusin( handler )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了1&lt;div id="test"&gt;点击触发&lt;div&gt; 123$("#test").focusin(function() &#123; //this指向 div元素&#125;); 代码：12345//input聚焦//给input元素增加23333文字$("input:first").focusin(function() &#123; $(this).val('23333')&#125;) 方法三：$ele.focusin( [eventData ], handler )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题1&lt;div id="test"&gt;点击触发&lt;div&gt; 1234$("#test").focusin(11111,function(e) &#123; //this指向 div元素 //e.date =&gt; 11111 传递数据&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hover事件]]></title>
      <url>%2F2017%2F02%2F15%2Fhover%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[hover = mouseenter + mouseleave在元素上移进移出切换其换色，一般通过2个事件配合就可以达到，这里用mouseenter与mouseleave，这样可以避免冒泡问题123456$(ele).mouseenter(function()&#123; $(this).css("background", '#bbffaa'); &#125;)$(ele).mouseleave(function()&#123; $(this).css("background", 'red');&#125;) 等同于123//只需要在hover方法中传递2个回调函数就可以了//不需要显示的绑定2个事件$(selector).hover(handlerIn, handlerOut) handlerIn(eventObject)：当鼠标指针进入元素时触发执行的事件函数 handlerOut(eventObject)：当鼠标指针离开元素时触发执行的事件函数代码：12345678910// hover()方法是同时绑定 mouseenter和 mouseleave事件。// 我们可以用它来简单地应用在 鼠标在元素上行为$("p").hover( function() &#123; $(this).css("background", 'red'); &#125;, function() &#123; $(this).css("background", '#bbffaa'); &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mouseenter与mouseleave事件]]></title>
      <url>%2F2017%2F02%2F15%2Fmouseenter%E4%B8%8Emouseleave%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[监听用户移动到内部的操作三种参数传递方式与mouseover和mouseout是一模一样 mouseenter事件和mouseover的区别 关键点就是：冒泡的方式处理问题简单的例子：mouseover为例：123&lt;div class="aaron2"&gt; &lt;p&gt;鼠标离开此区域触发mouseleave事件&lt;/p&gt;&lt;/div&gt; 如果在p元素与div元素都绑定mouseover事件，鼠标在离开p元素，但是没有离开div元素的时候，触发的结果:p元素响应事件div元素响应事件这里的问题是div为什么会被触发？ 原因就是事件冒泡的问题，p元素触发了mouseover，他会一直往上找父元素上的mouseover事件，如果父元素有mouseover事件就会被触发所以在这种情况下面，jQuery推荐我们使用 mouseenter事件 mouseenter事件只会在绑定它的元素上被调用，而不会在后代节点上被触发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mouseover与mouseout事件]]></title>
      <url>%2F2017%2F02%2F15%2Fmouseover%E4%B8%8Emouseout%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[监听用户的移入移出操作 方法一：$ele.mouseover()绑定$ele元素，不带任何参数一般是用来指定触发一个事件，用的比较少1&lt;div id="test"&gt;点击触发&lt;div&gt; 123456$("ele").mouseover(function()&#123; alert('触发指定事件')&#125;)$("#test").click(function()&#123; $("ele").mouseover() //指定触发事件 &#125;); 方法二：$ele.mouseover( handler(eventObject) )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了1&lt;div id="test"&gt;滑动触发&lt;div&gt; 123$("#test").mouseover(function() &#123; //this指向 div元素 &#125;); 方法三：$ele.mouseover( [eventData ], handler(eventObject) )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题1&lt;div id="test"&gt;点击触发&lt;div&gt; 1234$("#test").mouseover(11111,function(e) &#123; //this指向 div元素 //e.date =&gt; 11111 传递数据&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mousemove事件]]></title>
      <url>%2F2017%2F02%2F15%2Fmousemove%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[mousemove方法可以监听用户鼠标移动的操作 方法一：$ele.mousemove()绑定$ele元素，不带任何参数一般是用来指定触发一个事件，用的比较少1&lt;div id="test"&gt;点击触发&lt;div&gt; 123456$("ele").mousemove(function()&#123; alert('触发指定事件')&#125;)$("#test").click(function()&#123; $("ele").mousemove() //指定触发事件 &#125;); 方法二：$ele.mousemove( handler(eventObject) )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了1&lt;div id="test"&gt;滑动触发&lt;div&gt; 123$("#test").mousemove(function() &#123; //this指向 div元素 &#125;); 像:12345//绑定一个mousemove事件 //触发后修改内容 $(".aaron1").mousemove(function(e) &#123; $(this).find('p:last').html('移动的X位置：' + e.pageX) &#125;) 方法三：$ele.mousemove( [eventData ], handler(eventObject) )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题1&lt;div id="test"&gt;点击触发&lt;div&gt; 1234$("#test").mousemove(11111,function(e) &#123; //this指向 div元素 //e.date =&gt; 11111 传递数据&#125;); 像：123456789//不同函数传递数据 function data(e) &#123; $(this).find('p:last').html('数据:' + e.data) &#125; function a() &#123; $(".right").mousemove(1111, data) &#125; a();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mousedown与mouseup事件]]></title>
      <url>%2F2017%2F02%2F15%2Fmousedown%E4%B8%8Emouseup%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[mousedown方法可以监听用户鼠标按下的操作；mouseup方法可以监听用户鼠标弹起的操作 方法一：$ele.mousedown()绑定$ele元素，不带任何参数一般是用来指定触发一个事件，可能一般用的比较少1&lt;div id="test"&gt;点击触发&lt;div&gt; 123456$("ele").mousedown(function()&#123; alert('触发指定事件')&#125;)$("#test").mousedown(function()&#123; $("ele").mousedown() //手动指定触发事件 &#125;); 方法二：$ele.mousedown( handler(eventObject) )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了1&lt;div id="test"&gt;点击触发&lt;div&gt; 123$("#test").mousedown(function() &#123; //this指向 div元素&#125;); 方法三：$ele.mousedown( [eventData ], handler(eventObject) )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题1&lt;div id="test"&gt;点击触发&lt;div&gt; 1234$("#test").mousedown(11111,function(e) &#123; //this指向 div元素 //e.date =&gt; 11111 传递数据&#125;); 像:123456789//不同函数传递数据 function data(e) &#123; alert(e.data) //1111 &#125; function a() &#123; $("button:eq(2)").mousedown(1111, data) &#125; a(); mouseup与mousedown用法相似 mouseup事件触发需要以下几点： mouseup强调是松手触发，与mousedown是相反的 mouseup与mousedown组合起来就是click事件 如果用户在一个元素上按下鼠标按键，并且拖动鼠标离开这个元素，然后释放鼠标键，这仍然是算作mouseup事件任何鼠标按钮松手时都能触发mouseup事件 用event 对象的which区别按键，敲击鼠标左键which的值是1，敲击鼠标中键which的值是2，敲击鼠标右键which的值是3click与mousedown的区别：click事件其实是由mousedown于mouseup 2个动作构成，所以点击的动作只有在松手后才触发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[click与dbclick事件]]></title>
      <url>%2F2017%2F02%2F15%2Fclick%E4%B8%8Edbclick%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[click方法用于监听用户单击操作;dbclick方法用于监听用户双击操作 方法一：$ele.click()绑定$ele元素，不带任何参数一般是用来指定触发一个事件，用的比较少1&lt;div id="test"&gt;点击触发&lt;div&gt; 1234567$("ele").click(function()&#123; alert('触发指定事件')&#125;)$("#test").click(function()&#123; $("ele").click() //手动指定触发事件 &#125;); 方法二：$ele.click( handler(eventObject) )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数，这样可以针对事件的反馈做很多操作了，方法中的this是指向了绑定事件的元素1&lt;div id="test"&gt;点击触发&lt;div&gt; 123$("#test").click(function() &#123; //this指向 div元素&#125;); 方法三：$ele.click( [eventData ], handler(eventObject) )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题1&lt;div id="test"&gt;点击触发&lt;div&gt; 1234$("#test").click(11111,function(e) &#123; //this指向 div元素 //e.date =&gt; 11111 传递数据&#125;); 像：123456789//不同函数传递数据 function data(e) &#123; alert(e.data) //1111 &#125; function a() &#123; $("button:eq(2)").click(1111, data) &#125; a(); dblclick()的用法和click()的用法是类似的，可以参考以上click()的用法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery鼠标事件]]></title>
      <url>%2F2017%2F02%2F15%2FjQuery%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[click与dbclick事件click方法用于监听用户单击操作;dbclick方法用于监听用户双击操作 mousedown与mouseup事件mousedown方法可以监听用户鼠标按下的操作；mouseup方法可以监听用户鼠标弹起的操作 mousemove事件mousemove方法可以监听用户鼠标移动的操作 mouseover与mouseout事件监听用户的移入移出操作 mouseenter与mouseleave事件 moumouseenter = mouseovermouseleave = mouseout hover事件hover = mouseenter + mouseleave focusin事件聚焦事件 focusout事件失焦事件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery遍历之each()]]></title>
      <url>%2F2017%2F02%2F15%2FjQuery%E9%81%8D%E5%8E%86%E4%B9%8Beach%2F</url>
      <content type="text"><![CDATA[each() 方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数) 重点： each是一个for循环的包装迭代器 each通过回调的方式处理，并且会有2个固定的实参，索引与元素 each回调方法中的this指向当前迭代的dom元素案例1234&lt;ul&gt; &lt;li&gt;item-1&lt;/li&gt; &lt;li&gt;item-2&lt;/li&gt;&lt;/ul&gt; 开始迭代li，循环2次12345$("li").each(function(index, element) &#123; index 索引 0,1 element 是对应的li节点 li,li this 指向的是li&#125;) 代码12345//遍历所有的li//修改每个li内的字体颜色$("li").each(function(index, element) &#123; $(this).css('color','red')&#125;) 123456789(function() &#123; //遍历所有的li //修改偶数li内的字体颜色 $("li").each(function(index, element) &#123; if (index % 2) &#123; $(this).css('color','blue') &#125; &#125;)&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery遍历之add()方法]]></title>
      <url>%2F2017%2F02%2F15%2FjQuery%E9%81%8D%E5%8E%86%E4%B9%8Badd-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.add()的参数可以几乎接受任何的$()，包括一个jQuery选择器表达式，DOM元素，或HTML片段引用。 案例：操作：选择所有的li元素，之后把p元素也加入到li的合集中123456&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li&gt;list item 3&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;p元素&lt;/p&gt; 处理一：传递选择器1$('li').add('p') 处理二：传递dom元素1$('li').add(document.getElementsByTagName('p')[0]) 还有一种方式，就是动态创建P标签加入到合集，然后插入到指定的位置，但是这样就改变元素的本身的排列了1$('li').add('&lt;p&gt;新的p元素&lt;/p&gt;').appendTo(目标位置)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery遍历之siblings()]]></title>
      <url>%2F2017%2F02%2F15%2FjQuery%E9%81%8D%E5%8E%86%E4%B9%8Bsiblings%2F</url>
      <content type="text"><![CDATA[查找指定元素集合中每一个元素的同辈元素 理解节点查找关系：class=”item-1”,class=”item-3”就是class=”item-2”兄弟节点12345&lt;ul&gt; &lt;li class="item-1"&gt;1&lt;/li&gt; &lt;li class="item-2"&gt;2&lt;/li&gt; &lt;li class="item-3"&gt;3&lt;/li&gt;&lt;/ul&gt; siblings()无参数取得一个包含匹配的元素集合中每一个元素的同辈元素的元素集合12.siblings().css('border', '2px solid red')//找到class=item-2的所有兄弟节点,然后加上红色的边 siblings()方法选择性地接受同一类型选择器表达式12345$("button:last").click(function() &#123; //找到class=item-2的所有兄弟节点 //然后筛选出最后一个，加上蓝色的边 $('.item-2').siblings(':last').css('border', '2px solid blue')&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery遍历之prev()方法]]></title>
      <url>%2F2017%2F02%2F15%2FjQuery%E9%81%8D%E5%8E%86%E4%B9%8Bprev-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[快速查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合 理解节点查找关系：class=”item-1”就是class=”item-2”的兄弟节点12345&lt;ul class="level-3"&gt; &lt;li class="item-1"&gt;1&lt;/li&gt; &lt;li class="item-2"&gt;2&lt;/li&gt; &lt;li class="item-3"&gt;3&lt;/li&gt;&lt;/ul&gt; prev()无参数取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合12345&lt;ul&gt; &lt;li class="item-1"&gt;1&lt;/li&gt; &lt;li class="item-2"&gt;2&lt;/li&gt; &lt;li class="item-3"&gt;3&lt;/li&gt;&lt;/ul&gt; 12$('.item-2').prev().css('border', '1px solid red')//找到class=item-2所对应的上一个兄弟节点 prev()方法选择性地接受同一类型选择器表达式同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式123//找到class=item-2//然后筛选出最后一个，加上蓝色的边$('.item-3').prev(':last').css('border', '1px solid blue')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery遍历之next()方法]]></title>
      <url>%2F2017%2F02%2F15%2FjQuery%E9%81%8D%E5%8E%86%E4%B9%8Bnext-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合 理解节点查找关系：class=”item-2”是class=”item-1”元素的兄弟元素12345&lt;ul&gt; &lt;li class="item-1"&gt;1&lt;/li&gt; &lt;li class="item-2"&gt;2&lt;/li&gt; &lt;li class="item-3"&gt;3&lt;/li&gt;&lt;/ul&gt; next()无参数允许我们找遍元素集合中紧跟着这些元素的直接兄弟元素，并根据匹配的元素创建一个新的 jQuery 对象12345&lt;ul&gt; &lt;li class="item-1"&gt;1&lt;/li&gt; &lt;li class="item-2"&gt;2&lt;/li&gt; &lt;li class="item-3"&gt;3&lt;/li&gt;&lt;/ul&gt; 1234$("button:first").click(function() &#123; $('.item-1').next().css('border', '1px solid red') //给class=item-2的li加上红色的边&#125;) next()方法选择性地接受同一类型选择器表达式同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式12345$("button:last").click(function() &#123; //找到所有class=item-3的li //然后筛选出第一个li，加上蓝色的边 $('.item-2').next(':first').css('border', '1px solid blue')&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery遍历之closest()方法]]></title>
      <url>%2F2017%2F02%2F15%2FjQuery%E9%81%8D%E5%8E%86%E4%B9%8Bclosest-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[closest()方法接受一个匹配元素的选择器字符串从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素例如：在div元素中，往上查找li元素，可以这样表达1$("div").closet("li') 12345678$("button:first").click(function() &#123; $('.item').closest('.level').css('border', '1px solid red') /* 找到class="item"的li元素 通过closest方法往上找到class=".level"的元素 加上边框颜色 */&#125;) .parents()和.closest()区别: 起始位置不同：.closest开始于当前元素.parents开始于父元素 遍历的目标不同：.closest要找到指定的目标.parents遍历到文档根元素.closest向上查找，直到找到一个匹配的就停止查找.parents一直查找到根元素，并将匹配的元素加入集合 结果不同：.closest返回的是包含零个或一个元素的jquery对象.parents返回的是包含零个或一个或多个元素的jquery对象]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery遍历之parents()方法]]></title>
      <url>%2F2017%2F02%2F15%2FjQuery%E9%81%8D%E5%8E%86%E4%B9%8Bparents-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[类似find与children的区别，parent只会查找一级，parents则会往上一直查到查找到祖先节点 理解节点查找关系： 1 在li节点上找到祖辈元素div1$("li").parents() parents()无参数parents()方法允许我们能够在DOM树中搜索到这些元素的祖先元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象返回的元素秩序是从离他们最近的父级元素开始的1234$("button:first").click(function() &#123; $('.item').parents().css('border','1px solid red') //找到class="item"元素的所有祖辈元素并且附上一个红色的边框&#125;) parents()方法选择性地接受同一型选择器表达式同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式12345$("button:last").click(function() &#123; //找到当前元素的所有祖辈元素,筛选出class="first-div"的元素 //并且附上一个边 $('.item').parents('.first-div').css('border', '2px solid blue')&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery遍历之parent()方法]]></title>
      <url>%2F2017%2F02%2F15%2FjQuery%E9%81%8D%E5%8E%86%E4%B9%8Bparent-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[快速查找合集里面的每一个元素的父元素（这里可以理解为就是父亲-儿子的关系） 理解节点查找关系：12345&lt;div class="div"&gt; &lt;ul class="son"&gt; &lt;li class="grandson"&gt;1&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 查找ul的父元素div1$(ul).parent() parent()无参数parent()方法允许我们能够在DOM树中搜索到这些元素的父级元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象1234567$("button:first").click(function() &#123; $('.div').parent().css("border","1px solid red") /* 找到所有class=div的元素 找到它的父元素,并且加上一个红色的边框 */&#125;) parent()方法选择性地接受同一型选择器表达式同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式12345$("button:last").click(function() &#123; //找到所有class=item的父元素 //然后筛选出最后一个，加上蓝色的边 $('.item').parent(':last').css('border', '1px solid blue')&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery遍历之find()方法]]></title>
      <url>%2F2017%2F02%2F15%2FjQuery%E9%81%8D%E5%8E%86%E4%B9%8Bfind-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[快速查找DOM树中的元素的后代元素注意 children与find方法的区别，children是父子关系查找，find是后代关系（包含父子关系） 理解节点查找关系：12345&lt;div class="div"&gt; &lt;ul class="son"&gt; &lt;li class="grandson"&gt;1&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 代码如果是$(“div”).find(“li”)，此时，li与div是祖辈关系，通过find方法就可以快速的查找到了 .find()方法要注意的知识点：find是遍历当前元素集合中每个元素的后代。只要符合，不管是儿子辈，孙子辈都可以。与其他的树遍历方法不同，选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 ‘*’。find只在后代中遍历，不包括自己。选择器 context 是由 .find() 方法实现的；因此，$(‘.item-ii’).find(‘li’) 等价于 $(‘li’, ‘.item-ii’)(找到类名为item-ii的标签下的li标签) 注意重点：.find()和.children()方法是相似的1.children只查找第一级的子节点2.find查找范围包括子节点的所有后代节点代码：12345678$("button:first").click(function() &#123; $(".left").find("li:last").css("border","1px solid red") /* 在class="left"的元素中 找到后代元素li中的最后一个 并加上红色的边框 */ &#125;) 123456$("button:last").click(function() &#123; //找到所有p元素，然后筛选出子元素是span标签的节点 //改变其字体颜色 var $spans = $('span'); $("p").find($spans).css('color', 'red');&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery遍历之children()方法]]></title>
      <url>%2F2017%2F02%2F15%2FjQuery%E9%81%8D%E5%8E%86%E4%B9%8Bchildren-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[返回匹配元素集合中每个元素的子元素，添加可选参数可通过选择器进行过滤 理解节点查找关系：12345&lt;div class="div"&gt; &lt;ul class="son"&gt; &lt;li class="grandson"&gt;1&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 代码如果是$(“div”).children()，那么意味着只能找到ul，因为div与ul是父子关系，li与div是祖辈关系，因此无法找到 children()无参数允许我们通过在DOM树中对这些元素的直接子元素进行搜索，并且构造一个新的匹配元素的jQuery对象注意：jQuery是一个合集对象，所以通过children是匹配合集中每一给元素的第一级子元素1234 $("#bt1").click(function() &#123; $(".div").children().css("color","red") //找到所有class=div的元素节点，然后找到其对应的子元素，改变颜色&#125;) .children()方法选择性地接受同一类型选择器表达式$(“div”).children(“.selected”)同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式12345$("#bt2").click(function() &#123; //找到所有class=div的元素 //找到其对应的子元素ul，然后筛选出最后一个，给边宽加上颜色 $('.div').children(':last').css('border', '3px solid blue')&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的遍历]]></title>
      <url>%2F2017%2F02%2F15%2FjQuery%E9%81%8D%E5%8E%86%2F</url>
      <content type="text"><![CDATA[children()方法查找元素集合中每个元素的子元素 find()方法查找DOM树中的元素的后代元素 parent()方法查找合集里面的每一个元素的父元素 parents()方法查找合集里面的每一个元素的所有祖辈元素 closest()方法查找当前元素的父辈祖辈元素 next()方法查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合 prev()方法查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合 siblings()方法查找指定元素集合中每一个元素的同辈元素 add()方法元素添加到匹配的元素集合中 each()方法.each() 方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM删除包裹wrapInner()方法]]></title>
      <url>%2F2017%2F02%2F15%2FDOM%E5%88%A0%E9%99%A4%E5%8C%85%E8%A3%B9wrapInner-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.wrapInner( wrappingElement )：给集合中匹配的元素的内部，增加包裹的HTML结构代码：12&lt;div&gt;p元素&lt;/div&gt;&lt;div&gt;p元素&lt;/div&gt; 给所有元素增加一个p包裹1$('div').wrapInner('&lt;p&gt;&lt;/p&gt;') 最后的结构，匹配的div元素的内部元素被p给包裹了123456&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; .wrapInner( function ) ：允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行，返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容123$('div').wrapInner(function() &#123; return '&lt;p&gt;&lt;/p&gt;'; &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM包裹wrapAll()方法]]></title>
      <url>%2F2017%2F02%2F15%2FDOM%E5%8C%85%E8%A3%B9wrapAll-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.wrapAll( wrappingElement )：给集合中匹配的元素增加一个外面包裹HTML结构代码：12&lt;p&gt;p元素&lt;/p&gt;&lt;p&gt;p元素&lt;/p&gt; 给所有p元素增加一个div包裹1$('p').wrapAll('&lt;div&gt;&lt;/div&gt;') 最后的结构，2个P元素都增加了一个父div的结构1234&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; .wrapAll( function ) ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象通过回调的方式可以单独处理每一个元素以上面案例为例，123$('p').wrapAll(function() &#123; return '&lt;div&gt;&lt;div/&gt;'; &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM删除包裹unwrap()方法]]></title>
      <url>%2F2017%2F02%2F15%2FDOM%E5%88%A0%E9%99%A4%E5%8C%85%E8%A3%B9unwrap-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.unwarp()方法 ，作用与wrap方法是相反的。将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置案例：123&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; 保留内部元素p,删除父元素div12$('p').unwarp();//找到p元素，然后调用unwarp方法，这样只会删除父辈div元素了 结果：1&lt;p&gt;p元素&lt;/p&gt; 参看：1234567891011121314&lt;script type="text/javascript"&gt;$(".aaron1").on('click', function() &#123; //找到所有p元素，删除父容器div $('p').unwrap('&lt;div&gt;&lt;/div&gt;')&#125;)&lt;/script&gt;&lt;script type="text/javascript"&gt;$(".aaron2").on('click', function() &#123; //找到所有p元素，删除父容器div $('a').unwrap(function() &#123; return '&lt;div&gt;&lt;/div&gt;'; &#125;)&#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM包裹wrap()方法]]></title>
      <url>%2F2017%2F02%2F15%2FDOM%E5%8C%85%E8%A3%B9wrap-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[将元素用其他元素包裹起来，也就是给它增加一个父元素，针对这样的处理，JQuery提供了一个wrap方法 .wrap( wrappingElement )：在集合中匹配的每个元素周围包裹一个HTML结构p元素1&lt;p&gt;p元素&lt;/p&gt; 给p元素增加一个div包裹1$('p').wrap('&lt;div&gt;&lt;/div&gt;') 最后的结构，p元素增加了一个父div的结构123&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; .wrap( function ) ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象使用后的效果与直接传递参数是一样，只不过可以把代码写在函数体内部，写法不同而已1234$('p').wrap(function() &#123; return '&lt;div&gt;&lt;/div&gt;'; //与第一种类似，只是写法不一样&#125;) 注意：.wrap()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套了好几层深，但应该只包含一个核心的元素。每个匹配的元素都会被这种结构包裹。该方法返回原始的元素集，以便之后使用链式方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue开始之旅]]></title>
      <url>%2F2017%2F02%2F14%2FVue%E5%BC%80%E5%A7%8B%E4%B9%8B%E6%97%85%2F</url>
      <content type="text"><![CDATA[在初步了解React和Angular之后，又接触了Vue，在经过他人的经验介绍后选择了Vue 安装官网安装VueNPM安装cli脚手架 12345678910# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project#进入项目$ cd my-project# 安装依赖$ npm install#运行项目$ npm run dev vue2.0与1.0的改变对比Vue官方文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM替换replaceWith()和replaceAll()]]></title>
      <url>%2F2017%2F02%2F13%2FDOM%E6%9B%BF%E6%8D%A2replaceWith-%E5%92%8CreplaceAll%2F</url>
      <content type="text"><![CDATA[.replaceWith( newContent )：用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合简单来说：用$()选择节点A，调用replaceWith方法，传入一个新的内容B（HTML字符串，DOM元素，或者jQuery对象）用来替换选中的节点A学习代码,Html部分:12345&lt;div&gt; &lt;p&gt;第一段&lt;/p&gt; &lt;p&gt;第二段&lt;/p&gt; &lt;p&gt;第三段&lt;/p&gt;&lt;/div&gt; 替换第二段的节点与内容:12345&lt;script type="text/javascript"&gt;//找到第二个p元素//通过replaceWith删除并替换这个节点$("p:eq(1)").replaceWith('&lt;a style="color:red"&gt;替换第二段的内容&lt;/a&gt;')&lt;/script&gt; 结果如下：12345&lt;div&gt; &lt;p&gt;第一段&lt;/p&gt; &lt;a style="color:red"&gt;替换第二段的内容&lt;/a&gt;' &lt;p&gt;第三段&lt;/p&gt;&lt;/div&gt; .replaceAll( target ) ：用集合的匹配元素替换每个目标元素.replaceAll()和.replaceWith()功能类似，但是目标和源相反，用上述的HTML结构，我们用replaceAll处理1$('&lt;a style="color:red"&gt;替换第二段的内容&lt;/a&gt;').replaceAll('p:eq(1)') .replaceAll()和.replaceWith()功能类似，主要是目标和源的位置区别 .replaceWith()与.replaceAll() 方法会删除与节点相关联的所有数据和事件处理程序 .replaceWith()方法返回jQuery对象，所以可以和其他方法链接使用 .replaceWith()方法返回的jQuery对象引用的是替换前的节点，而不是通过replaceWith/replaceAll方法替换后的节点代码：12$("#div").append($("p:eq(1)").replaceWith('&lt;a style="color:red"&gt;replaceWith替换第二段的内容&lt;/a&gt;'))//找到第二个p标签，用·replaceWith()方法替换为颜色为红色的a标签，并把替换掉的添加到Id为div的标签中]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM拷贝clone()]]></title>
      <url>%2F2017%2F02%2F13%2FDOM%E6%8B%B7%E8%B4%9Dclone%2F</url>
      <content type="text"><![CDATA[.clone()方法深度 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。.clone(true) true可选 ：克隆附带的事件与数据 clone方法比较简单就是克隆节点，但是需要注意，如果节点有事件或者数据之类的其他处理，我们需要通过clone(ture)传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了Html代码：1234567&lt;body&gt;&lt;h2&gt;通过clone克隆元素&lt;/h2&gt; &lt;div class="left"&gt; &lt;div class="aaron1"&gt;点击,clone浅拷贝&lt;/div&gt; &lt;div class="aaron2"&gt;点击,clone深拷贝,可以继续触发创建&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; javascript代码：1234567&lt;script type="text/javascript"&gt; //只克隆节点 //不克隆事件 $(".aaron1").on('click', function() &#123; $(".left").append( $(this).clone().css('color','red') ) &#125;)&lt;/script&gt; 1234567&lt;script type="text/javascript"&gt; //克隆节点 //克隆事件 $(".aaron2").on('click', function() &#123; $(".left").append( $(this).clone(true).css('color','blue') ) &#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[保留数据的删除操作detach()]]></title>
      <url>%2F2017%2F02%2F13%2F%E4%BF%9D%E7%95%99%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9Cdetach%2F</url>
      <content type="text"><![CDATA[如果我们希望临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，并且能在下一个时间段让这个删除的节点显示到页面，这时候就可以使用detach方法来处理 注意：detach方法是JQuery特有的，所以它只能处理通过JQuery的方法绑定的事件或者数据Html代码：123456&lt;body&gt; &lt;p&gt;P元素1，默认给绑定一个点击事件&lt;/p&gt; &lt;p&gt;P元素2，默认给绑定一个点击事件&lt;/p&gt; &lt;button id="bt1"&gt;点击删除 p 元素&lt;/button&gt; &lt;button id="bt2"&gt;点击移动 p 元素&lt;/button&gt;&lt;/body&gt; JavaScript代码：12345678910111213141516&lt;script type="text/javascript"&gt; var p; $("#bt1").click(function() &#123; if (!$("p").length) return; //去重 //通过detach方法删除元素 //只是页面不可见，但是这个节点还是保存在内存中 //数据与事件都不会丢失 p = $("p").detach() &#125;); $("#bt2").click(function() &#123; //把p元素在添加到页面中 //事件还是存在 $("body").append(p); &#125;);&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[remove()的有参用法和无参用法]]></title>
      <url>%2F2017%2F02%2F13%2Fremove-%E7%9A%84%E6%9C%89%E5%8F%82%E7%94%A8%E6%B3%95%E5%92%8C%E6%97%A0%E5%8F%82%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[emove与empty一样，都是移除元素的方法，但是remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据Html代码： 12345678910111213&lt;body&gt; &lt;h2&gt;通过jQuery remove方法移除元素&lt;/h2&gt; &lt;div class="test1"&gt; &lt;p&gt;p元素1&lt;/p&gt; &lt;p&gt;p元素2&lt;/p&gt; &lt;/div&gt; &lt;div class="test2"&gt; &lt;p&gt;p元素3&lt;/p&gt; &lt;p&gt;p元素4&lt;/p&gt; &lt;/div&gt; &lt;button&gt;通过点击jQuery的empty移除元素&lt;/button&gt; &lt;button&gt;通过点击jQuery的empty移除指定元素&lt;/button&gt;&lt;/body&gt; JavaScript代码： 123456789101112&lt;script type="text/javascript"&gt; $("button:first").on('click', function() &#123; //删除整个 class=test1的div节点 $(".test1").remove() &#125;) $("button:last").on('click', function() &#123; //找到所有p元素中，包含了3的元素 //这个也是一个过滤器的处理 $("p").remove(":contains('3')") &#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM节点删除之empty()的基本用法]]></title>
      <url>%2F2017%2F02%2F13%2FDOM%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4%E4%B9%8Bempty-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[empty()不仅移除子元素（和其他后代元素），同样移除元素里的文本如果我们通过empty方法移除里面div的所有元素，它只是清空内部的html代码，但是标记仍然留在DOM中Html代码：1234567&lt;body&gt; &lt;h2&gt;通过empty移除元素&lt;/h2&gt; &lt;div id="test"&gt; &lt;p&gt;p元素1&lt;/p&gt; &lt;p&gt;p元素2&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; JavaScript代码：12345678&lt;button&gt;点击通过jQuery的empty移除元素&lt;/button&gt; &lt;script type="text/javascript"&gt; $("button").on('click', function() &#123; //通过empty移除了当前div元素下的所有p元素 //但是本身id=test的div元素没有被删除 $("#test").empty() &#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的insertBefore()方法]]></title>
      <url>%2F2017%2F02%2F13%2FjQuery%E4%B8%AD%E7%9A%84insertBefore-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.before()和.insertBefore()实现同样的功能。主要的区别是语法——内容和目标的位置。 对于before()选择表达式在函数前面，内容作为参数，而.insertBefore()刚好相反，内容在方法前面，它将被放在参数里元素的前面insertBefore将JQuery封装好的元素插入到指定元素的前面，如果元素前面有元素了，那将前面的元素前移，然后将JQuery对象插入1234567&lt;script type="text/javascript"&gt; $("#bt1").on('click', function() &#123; //在test1元素前后插入集合中每个匹配的元素 //不支持多参数 $('&lt;p style="color:red"&gt;测试insertBefore方法增加&lt;/p&gt;').insertBefore($(".test1")) &#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的insertAfter()方法]]></title>
      <url>%2F2017%2F02%2F13%2FjQuery%E4%B8%AD%E7%9A%84insertAfter-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.after()和.insertAfter() 实现同样的功能。主要的不同是语法——特别是（插入）内容和目标的位置。 对于after()选择表达式在函数的前面，参数是将要插入的内容。对于 .insertAfter(), 刚好相反，内容在方法前面，它将被放在参数里元素的后面insertAfter将JQuery封装好的元素插入到指定元素的后面，如果元素后面有元素了，那将后面的元素后移，然后将JQuery对象插入1234567&lt;script type="text/javascript"&gt;$("#btn1").on('click', function() &#123; //在box元素前后插入集合中每个匹配的元素 //不支持多参数 $('&lt;p style="color:red"&gt;测试insertAfter方法增加&lt;/p&gt;').insertAfter($(".box"))&#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular2初试]]></title>
      <url>%2F2017%2F02%2F13%2FAngular2%E5%88%9D%E8%AF%95%2F</url>
      <content type="text"><![CDATA[Angular2初试之利用angular-cli先说一说我在NPM angular-cli包时候遇到的小白问题在NPM安装的时候出现了Python环境配置错误问题解决办法：下载Python2.7版本，在安装界面(windows)下如下配置，然后重启电脑即可另外在 npm install 遇到其他Python问题可以参考这篇文章 创建工程Angular2为我们提供一个便捷的工程构建工具angular-cli，可以快速的搭建需要的开发环境 最新版的npm安装命令：1$ npm install -g angular-cli@latest 旧版本的更新命令：123$ npm uninstall -g angular-cli //卸载$ npm cache clean //清空缓存$ npm install -g angular-cli@latest //安装最新版本 创建工程文件命令：12$ ng new project-name //建立新项目$ cd project-nam //进入工程目录 本地端浏览：1$ ng server || $ ng s 指定端口：1$ ng server --ng server --host 0.0.0.0 --port 4000 项目打包：1$ ng build]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的prependTo()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84prependTo-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.prepend()和.prependTo()实现同样的功能，主要的不同是语法，插入的内容和目标的位置不同对于.prependTo() 而言，将要被插入的内容写在方法的前面，可以是选择器表达式或动态创建的标记，待插入内容的容器作为参数1234567&lt;script type="text/javascript"&gt; $("#bt2").on('click', function() &#123; //找到class="aaron2"的div节点 //然后通过prependTo内部的首位置添加一个新的p节点 $('&lt;p&gt;prependTo增加的p元素&lt;/p&gt;').prependTo($('.aaron2')) &#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的prepend()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84prepend-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[prepend()方法将指定元素插入到匹配元素里面作为它的第一个子元素 (如果要作为最后一个子元素插入用.append())对于.prepend() 而言，选择器表达式写在方法的前面，作为待插入内容的容器，将要被插入的内容作为方法的参数1234567&lt;script type="text/javascript"&gt; $("#bt1").on('click', function() &#123; //找到class="aaron1"的div节点 //然后通过prepend在内部的首位置添加一个新的p节点 $('.aaron1').prepend('&lt;p&gt;prepend增加的p元素&lt;/p&gt;') &#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的befor()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84befor-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[befor()前面是要插入的元素内容，而后面是被插入的对象 注意：before向元素的前边添加html代码，如果元素前面有元素了，那将前面的元素前移，然后将html代码插入123456&lt;script type="text/javascript"&gt; $("#bt1").on('click', function() &#123; //在匹配test1元素集合中的每个元素前面插入p元素 $(".test1").before('&lt;p style="color:red"&gt;before,在匹配元素之前增加&lt;/p&gt;', '&lt;p style="color:red"&gt;多参数&lt;/p&gt;') &#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的after()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84after-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[after()前面是被插入的对象，后面是要在对象内插入的元素内容 注意：after向元素的后边添加html代码，如果元素后面有元素了，那将后面的元素后移，然后将html代码插入1234567&lt;script type="text/javascript"&gt; $("#bt1").on('click', function() &#123; //在匹配test1元素集合中的每个元素后面插入p元素 $(".test2").after('&lt;p style="color:blue"&gt;after,在匹配元素之后增加&lt;/p&gt;', '&lt;p style="color:blue"&gt;多参数&lt;/p&gt;') &#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的appendTo()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84appendTo-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[appendTo：实际上，使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中appendTo()前面是要插入的元素内容，而后面是被插入的对象12345678910&lt;script type="text/javascript"&gt; $("#bt2").on('click', function() &#123; //.appendTo()刚好相反，内容在方法前面， //无论是一个选择器表达式 或创建作为标记上的标记 //它都将被插入到目标容器的末尾。 $('&lt;div class="appendTo"&gt;通过appendTo方法添加的元素&lt;/div&gt;').appendTo($(".content")) &#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的append()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84append-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[append：这个操作与对指定的元素执行原生的appendChild方法，将它们添加到文档中的情况类似append()前面是被插入的对象，后面是要在对象内插入的元素内容12345678 &lt;script type="text/javascript"&gt; $("#bt1").on('click', function() &#123; //.append(), 内容在方法的后面， //参数是将要插入的内容。 $(".content").append('&lt;div class="append"&gt;通过append方法添加的元素&lt;/div&gt;') &#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中DOM操作]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%ADDOM%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[大神都是从DOM开始的 JavaScript中的一点原生方法： 创建元素：document.createElement 设置属性：setAttribute 添加文本：innerHTML 加入文档：appendChildDOM节点的创建1234567891011&lt;script type="text/javascript"&gt; var $body = $('body'); $body.on("click",function() &#123; //通过jQuery生成div元素节点 var div = $("&lt;div&gt;动态创建DIV元素节点&lt;/div&gt;") //通过jQuery生成div属性节点 var div1 = $("&lt;div id='test' class='aaron'&gt;创建为属性节点&lt;/div&gt;") $body.append(div) $body.append(div1) &#125;)&lt;/script&gt; DOM节点的插入 DOM内部插入append() 与 appendTo() append(content):向每一个匹配的元素内部追加内容 appendTo(content):把所有匹配的元素追加到另一个指定的元素集合中DOM外部插入after() 与 before() after(content):在匹配元素集合在中的每一个元素后面插入参数所制定的内容作为其兄弟元素 before(content):根据参数设定，在匹配元素的前面插入内容DOM内部插入prepend() 与 prependTo() prepend(content):向每个匹配的元素内部前置内容 prependTo(content):把所有匹配的元素前置到另一个指定的元素集合中DOM内部插入insertAfter() 与 insertBefore() insertAfter():在目标元素前面插入集合中每个匹配的元素 insertBefore():在目标元素后面插入集合中每个匹配的元素DOM节点的删除 DOM节点删除之empty()的基本用法 remove()的有参用法和无参用法 保留数据的删除操作detach()DOM节点的复制与替换 DOM拷贝clone() DOM替换replaceWith()和replaceAll() DOM包裹wrap()方法wrap是针对单个dom元素处理 DOM删除包裹unwrap()方法unwrap是针对单个dom元素处理 DOM包裹wrapAll()方法wrapAll是针对集合dom元素处理 DOM删除包裹wrapInner()方法wrapInner是针对集合dom元素处理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的data()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84data-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[定义和用法data() 方法向被选元素附加数据，或者从被选元素获取数据。 向元素附加数据向被选元素附加数据 语法1$(selector).data(name,value) 参数 描述name : 必需;规定要设置的数据的名称value : 必需;规定要设置的数据的值 从元素返回数据从被选元素中返回附加的数据 语法1$(selector).data(name) 参数 描述name ： 可选。规定要取回的数据的名称如果没有规定名称，则该方法将以对象的形式从元素中返回所有存储的数据 学习代码：1234567891011121314151617&lt;script&gt; $(document).ready(function () &#123; /* ** 向p元素添加数据 a */ $("#btn1").click(function () &#123; $("p").data("a", "Hello! &lt;/br&gt;"); &#125;) /* ** 把p元素数据a取出，添加到div标签 */ $("#btn2").click(function () &#123; var a = $("p").data("a"); $("div").append(a); &#125;) &#125;)&lt;/script&gt; 123456&lt;body&gt; &lt;button id="btn1"&gt;赋值&lt;/button&gt; &lt;button id="btn2"&gt;取值&lt;/button&gt; &lt;p&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 使用对象向元素附加数据使用带有名称/值对的对象向被选元素添加数据。 语法1$(selector).data(object) 参数 描述object : 必需;规定包含名称/值对的对象 学习代码：12345678910111213&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; testObj=new Object(); testObj.greetingMorn="Good Morning!"; testObj.greetingEve="Good Evening!"; $("#btn1").click(function()&#123; $("div").data(testObj); &#125;); $("#btn2").click(function()&#123; alert($("div").data("greetingEve")); &#125;); // Good Evening!&#125;);&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的val()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84val-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[jQuery中有一个.val()方法主要是用于处理表单元素的值，比如 input, select 和 textarea .val()方法 .val()无参数，获取匹配的元素集合中第一个元素的当前值 .val( value )，设置匹配的元素集合中每个元素的值 .val( function ) ，一个用来返回设置值的函数注意事项： 通过.val()处理select元素， 当没有选择项被选中，它返回null .val()方法多用来设置表单的字段的值 如果select元素有multiple（多选）属性，并且至少一个选择项被选中， .val()方法返回一个数组，这个数组包含每个选中选择项的值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的removeAttr()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84removeAttr-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[removeAttr()删除方法.removeAttr( attributeName ) : 为匹配的元素集合中的每个元素中移除一个属性（attribute）学习代码：1234//从任何 p 元素中移除 id 属性：$("button").click(function()&#123; $("p").removeAttr("id");&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的attr()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84attr-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[jQuery中用attr()方法来获取和设置元素属性,attr是attribute（属性）的缩写，在jQuery DOM操作中会经常用到attr() attr()有4个表达式 attr(传入属性名)：获取属性的值 attr(属性名, 属性值)：设置属性的值 attr(属性名,函数值)：设置属性的函数值 attr(attributes)：给指定元素设置多个属性值，即：{属性名一: “属性值一” , 属性名二: “属性值二” , … … }注意的问题：dom中有个概念的区分：Attribute和Property翻译出来都是“属性”，《js高级程序设计》书中翻译为“特性”和“属性”。简单理解，Attribute就是dom节点自带的属性例如：html中常用的id、class、title、align等：而Property是这个DOM元素作为对象，其附加的内容，例如,tagName, nodeName, nodeType,, defaultChecked, 和 defaultSelected 使用.prop()方法进行取值或赋值等获取Attribute就需要用attr，获取Property就需要用prop 学习代码：1234&lt;script type="text/javascript"&gt; //找到第一个input，通过attr设置属性value的值 $('input:first').attr('value','嗯哼')&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的toggleClass()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84toggleClass-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.toggleClass( )方法：在匹配的元素集合中的每个元素上添加或删除一个或多个样式类,取决于这个样式类是否存在或值切换属性。即：如果存在（不存在）就删除（添加）一个类 .toggleClass( className )：在匹配的元素集合中的每个元素上用来切换的一个或多个（用空格隔开）样式类名 .toggleClass( className, switch )：一个布尔值，用于判断样式是否应该被添加或移除 .toggleClass( [switch ] )：一个用来判断样式类添加还是移除的 布尔值 toggleClass( function(index, class, switch) [, switch ] )：用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数注意事项： toggleClass是一个互斥的逻辑，也就是通过判断对应的元素上是否存在指定的2. toggleClass会保留原有的Class名后新增，通过空格隔开 学习代码:12345678&lt;script type="text/javascript"&gt; //给所有的tr元素加一个class="c"的样式 $("#table tr").toggleClass("c"); //给所有的偶数tr元素切换class="c"的样式 //所有基数的样式保留，偶数的被删除 $("#table tr:odd").toggleClass("c");&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的removeClass()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84removeClass-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.removeClass( )方法 .removeClass( [className ] )：每个匹配元素移除的一个或多个用空格隔开的样式名 .removeClass( function(index, class) ) ： 一个函数，返回一个或多个将要被移除的样式名 注意事项如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除 学习代码：1234&lt;script type="text/javascript"&gt; //class=left下div元素删除newClass样式 $('.left div').removeClass('newClass')&lt;/script&gt; 1234567891011121314&lt;script type="text/javascript"&gt; //.removeClass() 方法允许我们指定一个函数作为参数，返回将要被删除的样式 $('.right &gt; div:first').removeClass(function(index,className)&#123; //className = aa bb oClass //把div的className赋给下一个兄弟元素div上作为它的class $(this).next().addClass(className) //删除自己本身的oClass return 'oClass' &#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的addClass()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84addClass-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.addClass( className )方法 .addClass( className ) : 为每个匹配元素所要增加的一个或多个样式名 .addClass( function(index, currentClass) ) : 这个函数返回一个或更多用空格隔开的要增加的样式名 注意事项：.addClass()方法不会替换一个样式类名。它只是简单的添加一个样式类名到元素上简单的描述下：在p元素增加一个newClass的样式：1234&lt;p class="orgClass"&gt;&lt;script&gt;$("p").addClass("newClass")&lt;/script&gt; 那么p元素的class实际上是 class=”orgClass newClass”样式只会在原本的类上继续增加，通过空格分隔]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的text()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84text-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.text()方法得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容具体有3种用法： .text() 得到匹配元素集合中每个元素的合并文本，包括他们的后代 .text( textString ) 用于设置匹配元素内容的文本 .text( function(index, text) ) 用来返回设置文本内容的一个函数注意事项：.text()结果返回一个字符串，包含所有匹配元素的合并文本 1234&lt;script type="text/javascript"&gt; //通过.text()方法替换文本内容 $("a:first").text('替换第一个a标签的内容')&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的html()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84html-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.html()方法获取集合中第一个匹配元素的HTML内容 或 设置每一个匹配元素的html内容具体有3种用法： .html() 不传入值，就是获取集合中第一个匹配元素的HTML内容 .html( htmlString ) 设置每一个匹配元素的html内容 .html( function(index, oldhtml) ) 用来返回设置HTML内容的一个函数 ###注意事项：.html()方法内部使用的是DOM的innerHTML属性来处理的，所以在设置与获取上需要注意的一个最重要的问题，这个操作是针对整个HTML内容（不仅仅只是文本内容） 1234&lt;script type="text/javascript"&gt; //通过.html()方法替换html结构 $("div:first").html('整个div的子节点都被替换了')&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中的css()方法]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E4%B8%AD%E7%9A%84css-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[.css() 方法：获取元素样式属性的计算值或者设置元素的CSS属性 获取： .css( propertyName ) ：获取匹配元素集合中的第一个元素的样式属性的计算值 .css( propertyNames )：传递一组数组，返回一个对象结果设置： .css(propertyName, value )：设置CSS .css( propertyName, function )：可以传入一个回调函数，返回取到对应的值进行处理 .css( properties )：可以传一个对象，同时设置多个样式注意事项： 浏览器属性获取方式不同，在获取某些值的时候都jQuery采用统一的处理，比如颜色采用RBG，尺寸采用px .css()方法支持驼峰写法与大小写混搭的写法，内部做了容错的处理当一个数只被作为值（value）的时候， jQuery会将其转换为一个字符串，并添在字符串的结尾处添加px，例如 .css(“width”,50}) 与 .css(“width”,”50px”})一样学习代码： 1234567891011&lt;script type="text/javascript"&gt; //多种写法设置颜色 $('.fourth').css("background-color", "red") // $('.fifth').get(0).style.background="yellow" $('.fifth').css("backgroundColor", "yellow") &lt;/script&gt; &lt;script type="text/javascript"&gt; //多种写法设置字体大小 $('.fourth').css("font-size", "15px") $('.fifth').css("foontSize", "0.9em") &lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery属性样式基础]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[目前我只是粗浅的学习了几种jQuery属性和操作方法。这些方法对于 XML 文档和 HTML 文档均是适用的，除了：html() attr()设置或返回匹配元素的属性和值 removeAttr()从所有匹配的元素中移除指定的属性 addClass()向匹配的元素添加指定的类名 removeClass()从所有匹配的元素中删除全部或者指定的类 toggleClass()从匹配的元素中添加或删除一个类 css()设置或返回匹配元素的样式属性 html()设置或返回匹配的元素集合中的 HTML 内容 val()设置或返回匹配元素的值 text()设置或返回被选元素的文本内容 data()向被选元素附加数据，或者从被选元素获取数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery初试(选择器)]]></title>
      <url>%2F2017%2F02%2F11%2FjQuery%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[jQuery是javascript的一个子集，jQuery使人们不用顾虑浏览器的兼容性（我说的就是IE）。这里主要介绍jQuery的选择器 引入jQuery库：1&lt;script src="https://code.jquery.com/jquery-3.1.1.min.js"&gt;&lt;/script&gt; jQuery版的Hello，World！12345&lt;script&gt; $(document).ready(function () &#123; $("div").html("Hello,world!"); &#125;)&lt;/script&gt; jQuery中的页面加载后 “监听事件”的方法：1$(document).ready(function()&#123;&#125;); 等同于1window.onload = function()&#123;&#125;; 但ready事件优先于onload事件执行 简单的jQuery选择器jQuery基本选择器 ID选择器：$(“#id”) Class选择器：$(“.Class”) 标签选择器：$(“tagname”) 通配选择器：$(“ * “) 组选择器：$(“seletor1,seletor2,~N”) 层级选择器 1234567891011121314151617181920212223&lt;script type="text/javascript"&gt; //子选择器 //$('div &gt; p') 选择所有div元素里面的子元素P $('div&gt;p').css("border", "1px groove red");&lt;/script&gt;&lt;script type="text/javascript"&gt; //后代选择器 //$('div p') 选择所有div元素里面的p元素 $('div p').css("border", "1px groove red");&lt;/script&gt;&lt;script type="text/javascript"&gt; //相邻兄弟选择器 //选取prev后面的第一个的div兄弟节点 $('div+span').css("border", "3px groove red");&lt;/script&gt;&lt;script type="text/javascript"&gt; //一般相邻选择器 //选取prev后面的所有的div兄弟节点 $('.prev~div').css("border", "3px groove green");&lt;/script&gt; 基本筛选选择器 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script type="text/javascript"&gt; //找到第一个div $(".div:first").css("color", "#CD00CD");&lt;/script&gt;&lt;script type="text/javascript"&gt; //找到最后一个div $(".div:last").css("color", "#CD00CD");&lt;/script&gt;&lt;script type="text/javascript"&gt; //:even 选择所引值为偶数的元素，从 0 开始计数 $(".div:even").css("border", "3px groove red");&lt;/script&gt;&lt;script type="text/javascript"&gt; //:odd 选择所引值为奇数的元素，从 0 开始计数 $(".div:odd").css("border", "3px groove blue");&lt;/script&gt;&lt;script type="text/javascript"&gt; //:eq //选择单个 $(".aaron:eq(2)").css("border", "3px groove blue");&lt;/script&gt;&lt;script type="text/javascript"&gt; //:gt 选择匹配集合中所有索引值大于给定index参数的元素 $("aaron:gt(3)").css("border", "3px groove blue");&lt;/script&gt;&lt;script type="text/javascript"&gt; //:lt 选择匹配集合中所有索引值小于给定index参数的元素 //与:gt相反 $(".aaron:lt(2)").css("color", "#CD00CD");&lt;/script&gt;&lt;script type="text/javascript"&gt; //:not 选择所有元素去除不匹配给定的选择器的元素 //选中所有紧接着没有checked属性的input元素后的p元素，赋予颜色 $("input:not(:checked)+p").css("background-color", "#CD00CD");&lt;/script&gt; 内容筛选选择器 1234567891011121314151617181920212223&lt;script type="text/javascript"&gt; //查找所有class='div'中DOM元素中包含"box"的元素节点 //并且设置颜色 $(".div:contains('box')").css("color","#CD00CD");&lt;/script&gt;&lt;script type="text/javascript"&gt; //选择所有包含子元素或者文本的a元素 //增加一个蓝色的边框 $("a:parent").css("border", "3px groove blue");&lt;/script&gt;&lt;script type="text/javascript"&gt; //找到a元素下面的所有空节点(没有子元素) //增加一段文本与边框 $("a:empty").text(":empty").css("border", "3px groove red"); &lt;/script&gt;&lt;script type="text/javascript"&gt; //查找所有class='div'中DOM元素中包含"span"的元素节点 //并且设置颜色 $(".div:has(span)").css("color", "blue");&lt;/script&gt; 可见性筛选选择器 123456789&lt;script type="text/javascript"&gt; //查找id = div1的DOM元素,是否可见 show($("#div1:visible"));&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找id = div1的DOM元素,是否隐藏 show($("div1:hidden"));&lt;/script&gt; 属性筛选选择器 123456789101112131415161718192021222324252627282930313233343536373839&lt;script type="text/javascript"&gt; //查找所有div中，属性name=p1的div元素 $("div[name=p1]").css("border", "3px groove red");&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找所有div中，有属性p2的div元素 $("div[p2]").css("border", "3px groove blue");&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找所有div中，有属性name中的值只包含一个连字符“-”的div元素 $('div[name|="-"]').css("border", "3px groove #00FF00");&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找所有div中，有属性name中的值包含一个连字符“空”和“a”的div元素 $('div[name~="a"]').css("border", "3px groove #668B8B");&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找所有div中，属性name的值是用bob开头的 $('div[name^=bob]').css("border", "3px groove red");&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找所有div中，属性name的值是用bob结尾的 $("div[name$=bob]").css("border", "3px groove blue");&lt;/script&gt; &lt;script type="text/javascript"&gt; //查找所有div中，有属性name中的值包含一个test字符串的div元素 $('div[name*="test"]').css("border", "3px groove #00FF00");&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找所有div中，有属性testattr中的值没有包含"true"的div $('div[testattr!="true"]').css("border", "3px groove #668B8B");&lt;/script&gt; 子元素筛选选择器 123456789101112131415161718192021222324252627&lt;script type="text/javascript"&gt; //查找class="first-div"下的第一个a元素 //针对所有父级下的第一个 $('.first-div a:first-child').css("color", "#CD00CD");&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找class="first-div"下的最后一个a元素 //针对所有父级下的最后一个 //如果只有一个元素的话，last也是第一个元素 $('.first-div a:last-child').css("color", "red");&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找class="first-div"下的只有一个子元素的a元素 $('.first-div a:only-child').css("color", "blue");&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找class="last-div"下的第二个a元素 $('last-div a:nth-child(2)').css("color", "#CD00CD");&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找class="last-div"下的倒数第二个a元素 $('last-div a:nth-last-child(2)').css("color", "red");&lt;/script&gt; 表单元素选择器 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script type="text/javascript"&gt; //查找所有 input, textarea, select 和 button 元素 //:input 选择器基本上选择所有表单控件 $(':input').css("border", "1px groove red"); &lt;/script&gt;&lt;script type="text/javascript"&gt; //匹配所有input元素中类型为text的input元素 $('input:text').css("background", "#A2CD5A");&lt;/script&gt;&lt;script type="text/javascript"&gt; //匹配所有input元素中类型为password的input元素 $('input:password').css("background", "yellow"); &lt;/script&gt;&lt;script type="text/javascript"&gt; //匹配所有input元素中的单选按钮,并选中 $('input:radio').attr('checked','true');&lt;/script&gt;&lt;script type="text/javascript"&gt; //匹配所有input元素中的复选按钮,并选中 $('input:checkbox').attr('checked','true'); &lt;/script&gt;&lt;script type="text/javascript"&gt; //匹配所有input元素中的提交的按钮,修改背景颜色 $('input:submit').css("background", "#C6E2FF");&lt;/script&gt;&lt;script type="text/javascript"&gt; //匹配所有input元素中的图像类型的元素,修改背景颜色 $('input:img').css("background", "#F4A460");&lt;/script&gt;&lt;script type="text/javascript"&gt; //匹配所有input元素中类型为按钮的元素 $('input:button').css("background", "red");&lt;/script&gt;&lt;script type="text/javascript"&gt; //匹配所有input元素中类型为file的元素 $('input:file').css("background", "#CD1076");&lt;/script&gt; 表单对象属性选择器 123456789101112131415161718192021&lt;script type="text/javascript"&gt; //查找所有input所有可用的（未被禁用的元素）input元素。 $('input:enabled').css("border", "2px groove red");&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找所有input所有不可用的（被禁用的元素）input元素。 $('input:disabled').css("border", "2px groove blue");&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找所有input所有勾选的元素(单选框,复选框) //移除input的checked属性 $('input:checked').removeAttr('checked')&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找所有option元素中,有selected属性被选中的选项 //移除option的selected属性 $('option:selected').removeAttr('selected')&lt;/script&gt; 特殊选择器thisJavaScript原生DOM处理 1234567&lt;script type="text/javascript"&gt; var p1 = document.getElementById('test1') p1.addEventListener('click',function()&#123; //直接通过dom的方法改变颜色 this.style.color = "red"; &#125;,false);&lt;/script&gt; jQuery处理123456&lt;script type="text/javascript"&gt; $('#test2').click(function()&#123; //通过包装成jQuery对象改变颜色 $(this).css('color','blue'); &#125;)&lt;/script&gt; Dom对象转换jQuery对象123456789var div = document.getElementsByTagName('div'); //dom对象 div[1].style.color = "blue"; //将dom节点div转化为$div的jquery对象 var $div = $(div); // var $first = $div.first(); //找到第一个div元素 // $first.css('color', 'red'); //给第一个元素设置颜色 $div.get(0).style.color = "red"; $("div").get($div.length -1).style.color = "pink"; jQuery对象转换Dom对象123var $div = $('div'); //jQuery对象 var div = $div.get(0); div.style.color = 'red'; //操作dom对象的属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript面向对象初步学习]]></title>
      <url>%2F2017%2F02%2F11%2FJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[面向对象三大基本特性：封装，继承，多态12345678910111213141516171819202122232425262728293031323334353637383940414243444546var dog = &#123; name: "Pancake", legs: 4, isAwesome: true&#125;//给对象添加方法dog.back = function () &#123; console.log("My name is " + this.name + "!")&#125;dog.back() //My name is Pancake!/* ** 给dog对象添加名为back属性 并给它分配了一个函数 ** 该函数使用了this.name 这会访问对象的name属性中存储的值 **///在多个对象之间共享方法//1.先创建一个函数function speak() &#123; console.log(this.sound + " My name is " + this.name + "!")&#125;//2.创建多个对象var cat = &#123; sound: "Miaow", name: "Mittens", speak: speak&#125;var pig = &#123; sound: "Oink", name: "Charlie", speak: speak&#125;//3.调用speak方法cat.speak() //Miaow My name is Mittens!pig.speak() //Oink My name is Charlie!//构造方法函数function Car(x, y) &#123; this.x = x //构造方法Car接受参数 x,y this.y = x //添加属性 this.x this.y&#125;//调用Car构造方法var tesla = new Car(10, 20)tesla //Car &#123;x: 10, y: 10&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React初试]]></title>
      <url>%2F2017%2F02%2F11%2FReact%E5%88%9D%E8%AF%95%2F</url>
      <content type="text"><![CDATA[前几天学习了React.js(我其实连jQuery还没有学好)，我就先随便写点，目前就会用React写出Hello，World！（大大的尴尬） 1.1 CDN引用React需要引入三个库:react.min.js - React 的核心库react-dom.min.js - 提供与 DOM 相关的功能browser.min.js - 用于将 JSX 语法转为 JavaScript 语法 两个React库12&lt;script src="//cdn.bootcss.com/react/15.4.2/react.js"&gt;&lt;/script&gt;&lt;script src="//cdn.bootcss.com/react/15.4.2/react-dom.js"&gt;&lt;/script&gt; 和一个jsx语法解析库1&lt;script src="//cdn.bootcss.com/babel-core/6.1.19/browser.min.js"&gt;&lt;/script&gt; 1.2 Heool,world!script部分代码，必须在script后面加上 type=”text/babel”下面是React版的Hello，World!1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); Html代码：1&lt;div id="example"&gt;&lt;/div&gt; 以下内容摘抄自菜鸟教程，纯属凑字，我按照教程实验并没有起到任何作用，不知道哪里写的不对，希望有会得同学教一教我！1.3 通过NPM安装React第一步、安装全局包123$ npm install babel -g$ npm install webpack -g$ npm install webpack-dev-server --save-dev | npm install webpack -g 第二步、创建根目录创建一个根目录，目录名为：reactApp，再使用 npm init 初始化，生成 package.json 文件：1234567891011121314151617181920212223242526272829$ mkdir reactApp$ cd reactApp/$ npm initname: (react) zhengzhiyuuversion: (1.0.0)description: 测试entry point: (index.js)test command:git repository:keywords:author:license: (ISC)About to write to D:\react\package.json:&#123; "name": "zhengzhiyuu", "version": "1.0.0", "description": "测试", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC"&#125;Is this ok? (yes) 第三步、添加依赖包及插件因为要使用 React, 所以需要先安装它，–save 命令用于将包添加至 package.json 文件。12$ npm install react --save$ npm install react-dom --save 同时我们也要安装一些 babel 插件1234$ npm install babel-core$ npm install babel-loader$ npm install babel-preset-react$ npm install babel-preset-es2015 第四步、创建文件1234$ touch index.html$ touch App.jsx$ touch main.js$ touch webpack.config.js 第五步、设置编译器，服务器，载入器打开 webpack.config.js 文件添加以下代码:12345678910111213141516171819202122232425262728 var config = &#123; entry: './main.js', output: &#123; path:'./', filename: 'index.js', &#125;, devServer: &#123; inline: true, port: 7777 &#125;, module: &#123; loaders: [ &#123; test: /\.jsx?$/, exclude: /node_modules/, loader: 'babel', query: &#123; presets: ['es2015', 'react'] &#125; &#125;] &#125; &#125;module.exports = config; entry: 指定打包的入口文件 main.js。 output：配置打包结果，path定义了输出的文件夹，filename则定义了打包结果文件的名称。 devServer：设置服务器端口号为 7777，端口后你可以自己设定 。module：定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。 现在打开 package.json 文件，找到 “scripts” 中的 “test” , “echo \”Error: no test specified\” &amp;&amp; exit 1” 使用以下代码替换：1"start": "webpack-dev-server --hot" 现在我们可以使用 npm start 命令来启动服务。–hot 命令会在文件变化后重新载入，这样我们就不需要在代码修改后重新刷新浏览器就能看到变化。 第六步、index.html设置 div id = “app” 为我们应用的根元素，并引入 index.js 脚本文件。1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset = "UTF-8"&gt; &lt;title&gt;React App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id = "app"&gt;&lt;/div&gt; &lt;script src = "index.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 第七步、App.jsx 和 main.js这是第一个 react 组件这个组件将输出 Hello World!。App.jsx 文件代码:12345678910111213import React from 'react';class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; Hello World!&lt;br /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 需要引入组件并将其渲染到根元素 App 上，这样才可以在浏览器上看到它。main.js 文件代码:123456import React from 'react';import ReactDOM from 'react-dom';import App from './App.jsx';ReactDOM.render(&lt;App /&gt;, document.getElementById('app')) 第八步、运行服务完成以上配置后，即可运行该服务：1$ npm start]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017年的元宵节]]></title>
      <url>%2F2017%2F02%2F11%2F2017%E5%B9%B4%E7%9A%84%E5%85%83%E5%AE%B5%E8%8A%82%2F</url>
      <content type="text"><![CDATA[今天是我拥有博客的第二天，然而我还依然是一个小白。昨天匆匆搭建完博客就草草了事了，然后发现我的博客没有评论和阅读统计，这个怎么可以，所以我就照着NexT的指导用了第三方插件，由于有了昨天的基础，所以今天的人任务十分的顺利，没有丝毫意外的有了在我看起来可以装X的东西（在其他人眼里这就是渣渣一样的）。不管怎么说，自己做的东西总是觉得是好的，即便它是别人没有要的了已经。我做博客其实是想写一些笔记什么的，但是我发现我没有什么可以写的(连Markdown语法还没有学会)，我这个人堪称无聊至极，还是一个什么都不会的笨蛋，并且一无所有。我学习javascript已经很长时间了，可是到现在我都没有学到皮毛，只是懂了一些最基础的知识，可能真的是因为我是一个差等生吧，从小到大一直如此。也是一个彻头彻尾的loser，无论生活与爱情。谨此纪念我二十多年的失败人生，另外今天是元宵节，某人~元宵节快乐！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的第一篇文章]]></title>
      <url>%2F2017%2F02%2F10%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[不知道怎么突然就想做一个博客，可能是因为我的某种愿望没有达成吧！然后我就突发奇想的用到了傻瓜博客框架hexo，最开始我就想傻瓜式的应该好弄吧，结果我发现我不是傻瓜，我比傻瓜还傻瓜~~ 看了一下午的教程才学会用hexo，不怪某人说我笨死。我看网上都是自己在研究完别人的教程再自己写一个教程，然后我就不写了，自己还没学明白那！不过我要感谢简书的代码咖啡，他的教程写的不错！ 点此跳转]]></content>
    </entry>

    
  
  
</search>
